#ifdef __cplusplus
extern "C" {
#endif
/*
ANSI C code generated by SmallEiffel The GNU Eiffel Compiler
Release -0.74 Beta #18 (Monday March 4th 2002)
Copyright (C), 1994-2002 - LORIA - UHP - INRIA - FRANCE
Dominique COLNET and Suzanne COLLIN - SmallEiffel@loria.fr
http://SmallEiffel.loria.fr
C Compiler options used: -pipe -O2 `sdl-config --libs`
*/
#ifdef __cplusplus
}
#endif
#include "bliss.h"
#ifdef __cplusplus
extern "C" {
#endif
/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmallEiffel@loria.fr
--                       http://SmallEiffel.loria.fr
--
*/
/*
  This file (SmallEiffel/sys/runtime/base.c) is included for _all_ modes of
  compilation (-boost, -no_check, ... -all_check, -debug_check).
*/

/*
  The wrapper for `malloc' (generated C code is supposed to use
  only `se_malloc' instead of direct `malloc').
*/
void* se_malloc(size_t size) {
  void *result = malloc(size);
  if (result == NULL) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif SE_NO_CHECK
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory.\n");
  se_print_run_time_stack();
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}

/*
  The wrapper for `calloc' (generated C code is supposed to use
  only `se_calloc' instead of direct `calloc').
*/
void* se_calloc(size_t nmemb, size_t size) {
  void *result = calloc(nmemb,size);
  if (result == NULL) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif SE_NO_CHECK
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory.\n");
  se_print_run_time_stack();
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}
T102 M102=0;
T89 M89={89};
T96 M96={96,0,0,0,0,0,0,0,0,0,0};
T167 M167={167};
T161 M161={161};
T165 M165={165};
T218 M218={218,NULL,0};
T74 M74={74,NULL,NULL,NULL,NULL,NULL,0,0,0,0,NULL,0,0,0,0,NULL,0,0,0,0,0,0,0,NULL};
T205 M205={205,NULL,NULL,0,0,0,0};
T184 M184={184,NULL,0,0};
T175 M175={175};
T172 M172={172};
T189 M189={189,NULL,0,NULL};
T134 M134={134,NULL,0,0,0};
T174 M174={174};
T146 M146={146,NULL,0,0,0};
T138 M138={138,0,0,NULL};
T131 M131={131};
T114 M114={114,NULL,NULL};
T71 M71={71,NULL,NULL,NULL,NULL,NULL,0,0,0,0,NULL,0,0,0,NULL,0};
T212 M212={212,0,0,NULL,0};
T171 M171={171};
T140 M140={140,NULL,0,0,0};
T23 M23={23,0};
T43 M43={43,NULL,0,0,0,NULL,0};
T59 M59={59,0,NULL,NULL,0,NULL};
T47 M47=0;
T61 M61={61,NULL,0,0,0,NULL,0};
T125 M125={125,NULL,NULL};
T163 M163={163,NULL,NULL,NULL};
T178 M178={178};
T99 M99={99,NULL,0,NULL};
T81 M81={81,0,NULL,NULL,0,NULL};
T137 M137={137,NULL,0,NULL,0,0,0,0,NULL,0,0,0,0};
T93 M93={93,0,0,0,0,NULL,NULL};
T170 M170={170};
T180 M180={180,NULL,0,0,0};
T166 M166={166};
T48 M48={48,0,NULL};
T185 M185={185,NULL,0,0,0};
T72 M72={72,NULL,NULL,NULL,NULL,NULL,0,0,0,0,NULL,0,0,0};
T213 M213={213,0,NULL,0};
T50 M50={50,0,0,NULL};
T82 M82={82,NULL,NULL};
T66 M66={66,NULL,NULL};
T149 M149={149,NULL,NULL,NULL,0,0};
T73 M73={73,NULL,NULL,NULL,NULL,NULL,0,0,0,0,NULL,0,0,0};
T122 M122={122,NULL,NULL};
T129 M129={129,0,0,0,NULL,NULL,0,NULL,0,NULL,0,NULL,0,NULL,0};
T176 M176={176};
T162 M162={162,NULL,0,0,0,NULL,0};
T124 M124={124,0,NULL,NULL,0,NULL};
T77 M77={77,NULL,0,0,0,NULL,0};
T64 M64={64,NULL,NULL,0,0};
T153 M153={153,NULL,0,0,0};
T169 M169={169};
T197 M197={197,NULL,0,0,0};
T41 M41={41,NULL,NULL};
T111 M111={111,NULL,0};
T69 M69={69,NULL,NULL,NULL,NULL,NULL,0,0,0,0,NULL,0,0,0,NULL,0,0};
T211 M211={211,0,0,0,0,0};
T55 M55={55,NULL,0,0,0,NULL,0};
T109 M109={109,0,NULL};
T57 M57={57,NULL,0,NULL};
T65 M65={65,0,NULL,NULL,0,NULL};
T179 M179={179};
T210 M210={210,NULL,NULL};
T139 M139={139,0,0,NULL,NULL,NULL,0};
T67 M67={67,NULL,NULL,NULL,NULL,NULL,0,0,0,0,NULL,0,0,0};
T7 M7={7,NULL,0,0};
T168 M168={168};
T54 M54={54,NULL,0};
T56 M56={56,NULL,0,0,0,NULL,0};
T130 M130={130,NULL,NULL,0,NULL,0,0,0,0};
T83 M83={83,NULL,0};
T200 M200={200,NULL,0,0,0,NULL,0};
T158 M158={158,NULL,0,0,0};
T201 M201={201,NULL,NULL,NULL};
T209 M209={209,NULL,NULL};
T95 M95={95,0,0,0,0,0,0,NULL,0,0};
T45 M45={45,NULL,NULL,NULL};
T78 M78={78,NULL,0,NULL};
T16 M16={16,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,0,NULL,NULL};
T203 M203={203,0,0,0,NULL,0,0,0,0,0,0};
T94 M94={94,0,0,0,0,0,0,0,0,0,0,NULL,NULL};
T76 M76={76,0,0,0,NULL,NULL};
T173 M173={173};
T22 M22={22,0,0,0,0,0,0};
T143 M143={143,NULL,0,0,0};
T150 M150={150,NULL,0,0,0};
T28 M28={28,NULL,0,NULL,NULL,NULL,NULL,NULL,NULL,0,0,0,0,0,0,0,0,0,NULL};
T135 M135={135,0,NULL,NULL,0};
T193 M193={193,0,0,0,0,NULL,0};
T195 M195={195,NULL,0,0,0};
T51 M51={51,NULL,NULL,NULL};
T60 M60={60,NULL,NULL};
T206 M206={206};
T136 M136={136,0,0,0,0};
T183 M183={183,NULL,0,NULL};
T208 M208={208,0,0,NULL};
T88 M88={88,NULL,NULL};
T113 M113={113,NULL,NULL};
T39 M39={39,0,NULL,NULL,0,NULL};
T127 M127={127,NULL,NULL};
T107 M107={107,0,NULL,NULL,0,NULL};
T80 M80={80,NULL,NULL,NULL,0};
T62 M62={62,NULL,NULL,NULL};
T118 M118={118,NULL,0,0,0};
T177 M177={177};
T188 M188={188,NULL,0,0,0,NULL,0};
T75 M75={75,NULL,NULL,NULL,NULL,NULL,0,0,0,0,NULL,0,0,0,0,NULL};
/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmallEiffel@loria.fr
--                       http://SmallEiffel.loria.fr
--
*/

/*
  This file (SmallEiffel/sys/runtime/boost.c) is automatically included when
  `run_control.boost' is true (ie. only for mode -boost).
*/

void se_print_run_time_stack (void) {
  fprintf(SE_ERR,"Eiffel program crash at run time.\n");
  fprintf(SE_ERR,"No trace when using option \"-boost\"\n");
}

void se_signal_handler(int sig) {
  printf("Received signal %d (man signal).\n",sig);
  se_print_run_time_stack();
  exit(EXIT_FAILURE);
}
/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmallEiffel@loria.fr
--                       http://SmallEiffel.loria.fr
--
*/

/*
   This file (SmallEiffel/sys/runtime/gc_lib.c) is automatically included
   when the Garbage Collector is used (default, unless option -no_gc has been
   selected).
*/

int se_gc_strategy = SE_GC_DEFAULT_MEMORY_STRATEGY;

int collector_counter = 0;

static void gcna_align_mark(rsoc*c,void*o);
static rsoc*rsocfl=NULL; /* ReSizable Object Chunk Free List. */

void**stack_bottom;
mch**gcmt=NULL; /* Garbage Collector Main Table. */
int gcmt_max=2048;
int gcmt_used=0;
fsoc*fsocfl=NULL; /* Fixed Size Object Chunk Free List. */
int gc_is_off=1;
unsigned int fsoc_count=0;
unsigned int rsoc_count=0;
void*gcmt_tail_addr=NULL;

static int chunk_rounded(int size) {
  int rounded_size = size;
  int diff = rounded_size%RSOC_SIZE;

  if (diff != 0) rounded_size += (RSOC_SIZE-diff);
  return rounded_size;
}

static void free_and_remove_from_gcmt(mch* c) {
  /* Remove and free the chunk `c' from the
   * gcmt (Garbage Collector Main Table).
   */
  mch**p=(gcmt+gcmt_used-1);
  mch*save=*p;
  mch*save2;
  p--;
  while(save != c) {
    save2 = save;
    save = *p;
    *p = save2;
    p--;
  }
  free(c);
  gcmt_used--;
}

static void may_free_rsocfl(void) {
  /* May free all chunks of `rsocfl' (ReSizable Object Chunk Free List)
     in some circumstances.
  */
  rsoc* next, *current;
  int count = rsocfl_count();
  if ((count > 50) && (count > (rsoc_count >> 1))) {
    current=rsocfl;
    rsocfl=NULL;
    while (current != NULL) {
      next=current->next;
      if (current->isize == current->header.size) {
	free_and_remove_from_gcmt(((mch*)current));
	rsoc_count--;
      }
      else {
	current->next=rsocfl;
	rsocfl=current;
      }
      current = next;
    }
  }
}

void gc_sweep(void) {
  mch** p2 = gcmt;
  mch** p1 = gcmt+1;
  mch**eogcmt=gcmt+gcmt_used;
  if (FREE_CHUNK((*p2)->state_type)) {
    if (RSO_FREE_CHUNK == ((*p2)->state_type)) {
      ((rsoc*)(*p2))->next=NULL;
      rsocfl=((rsoc*)(*p2));
    }
    else {
      rsocfl=NULL;
    }
  }
  else {
    ((*gcmt)->swfp)(*p2);
    if (RSO_FREE_CHUNK==((*p2)->state_type)) {
      ((rsoc*)(*p2))->next=NULL;
      rsocfl=((rsoc*)(*p2));
    }
    else {
      rsocfl=NULL;
    }
  }
  while (p1 < eogcmt) {
    if (FREE_CHUNK((*p1)->state_type)) {
      if (RSO_FREE_CHUNK == ((*p1)->state_type)) {
	if (RSO_FREE_CHUNK == ((*p2)->state_type)) {
	  if (((char*)(*p2))+(*p2)->size == ((char*)(*p1))) {
	    ((*p2)->size)+=((*p1)->size);
	    p1++;
	  }
	  else {
	    ((rsoc*)(*p1))->next=rsocfl;
	    rsocfl=((rsoc*)(*p1));
	    *(p2+1)=*p1; p2++; p1++;
	  }
	}
	else {
	  ((rsoc*)(*p1))->next=rsocfl;
	  rsocfl=((rsoc*)(*p1));
	  *(p2+1)=*p1; p2++; p1++;
	}
      }
      else {
	*(p2+1)=*p1; p2++; p1++;
      }
    }
    else {
      ((*p1)->swfp)(*p1);
      if (RSO_FREE_CHUNK == ((*p1)->state_type)) {
	if (RSO_FREE_CHUNK == ((*p2)->state_type)) {
	  if (((char*)(*p2))+(*p2)->size == ((char*)(*p1))) {
	    ((*p2)->size)+=((*p1)->size);
	    p1++;
	  }
	  else {
	    ((rsoc*)(*p1))->next=rsocfl;
	    rsocfl=((rsoc*)(*p1));
	    *(p2+1)=*p1; p2++; p1++;
	  }
	}
	else {
	  ((rsoc*)(*p1))->next=rsocfl;
	  rsocfl=((rsoc*)(*p1));
	  *(p2+1)=*p1; p2++; p1++;
	}
      }
      else {
	*(p2+1)=*p1; p2++; p1++;
      }
    }
  }
  gcmt_used=(p2-gcmt)+1;
  may_free_rsocfl();
}

void gc_mark(void*p) {
  if ((p>((void*)*gcmt))&&(p<=gcmt_tail_addr)) {
    int i1=0;
    int i2=gcmt_used-1;
    int m=i2>>1;
    mch*c;
    for (;i2>i1;m=((i1+i2)>>1)) {
      if (p<=((void*)gcmt[m+1])) {
	i2=m;
      }
      else {
	i1=m+1;
      }
    }
    c=gcmt[i2];
    if (!(FREE_CHUNK(c->state_type))) {
      (c->amfp)(c,p);
    }
  }
}

int gc_stack_size(void) {
  void*stack_top[2]={NULL,NULL};
  if (stack_top > stack_bottom) {
    return ((void**)stack_top)-((void**)stack_bottom);
  }
  else {
    return ((void**)stack_bottom)-((void**)stack_top);
  }
}

/*
  To delay Garbage Collection when the stack is too large.
  To allow fast increase of ceils.
*/
#define FSOC_LIMIT (10240/((FSOC_SIZE)>>10))
#define RSOC_LIMIT (10240/((RSOC_SIZE)>>10))

/*
  When stack is too large, collection may be delayed.
*/
#define GCLARGESTACK 50000

int garbage_delayed(void) {
  /*
    To delay the first GC call.
  */
  if (gc_stack_size() > GCLARGESTACK) {
    if (fsoc_count_ceil <= fsoc_count) {
      if (rsoc_count_ceil <= rsoc_count) {
	if ((fsoc_count<FSOC_LIMIT)&&(rsoc_count<RSOC_LIMIT)) {
	  fsoc_count_ceil++;
	  rsoc_count_ceil++;
	  return 1;
	}
	else return 0;
      }
      else {
	if (fsoc_count<FSOC_LIMIT) {
	  fsoc_count_ceil++;
	  return 1;
	}
	else return 0;
      }
    }
    else {
      if (rsoc_count_ceil <= rsoc_count) {
	if (rsoc_count<RSOC_LIMIT) {
	  rsoc_count_ceil++;
	  return 1;
	}
	else return 0;
      }
      else return 0;
    }
  }
  else {
    return 0;
  }
}

void gc_update_ceils(void) {
  /* This function is automatically called after each collection
     cycle.
  */
  if (se_gc_strategy == SE_GC_LOW_MEMORY_STRATEGY) {
    fsoc_count_ceil = fsoc_count;
    rsoc_count_ceil = rsoc_count;
    /* Todo: we should also consider to free unused chunks here. */
    return;
  }
  if (se_gc_strategy == SE_GC_HIGH_MEMORY_STRATEGY) {
    fsoc_count_ceil = (256 + fsoc_count) << 2;
    rsoc_count_ceil = (256 + rsoc_count) << 2;
    return;
  }
  /* The SE_GC_DEFAULT_MEMORY_STRATEGY. */
  /* Compute fsoc_count_ceil: */
  if (fsocfl == NULL) {
    if (fsoc_count >= fsoc_count_ceil) {
      if (fsoc_count_ceil < FSOC_LIMIT) {
	fsoc_count_ceil <<= 1;
      }
      else {
	int c = fsoc_count + (fsoc_count/3);
	if (fsoc_count_ceil < c)
	  fsoc_count_ceil = c;
      }
    }
  }
  else {
    if (fsoc_count_ceil < fsoc_count) {
      fsoc_count_ceil = fsoc_count;
    }
  }
  /* Compute rsoc_count_ceil: */
  if (rsocfl == NULL) {
    if (rsoc_count >= rsoc_count_ceil) {
      if (rsoc_count_ceil < RSOC_LIMIT) {
	rsoc_count_ceil <<= 1;
      }
      else {
	int c = rsoc_count + (rsoc_count / 3);
	if (rsoc_count_ceil < c) {
	  rsoc_count_ceil = c;
	}
      }
    }
  }
  else {
    if (rsoc_count_ceil < rsoc_count) {
      rsoc_count_ceil = rsoc_count;
    }
  }
}

static void gc_add_into_gcmt(mch*c) {
  /* Update the `gcmt' (Garbage Collector Main Table) by adding the
     new `mch' (Memory Chunk Header).
  */
  mch** p;
  if (gcmt_used == gcmt_max) {
    gcmt_max <<= 1;
    gcmt = ((mch**)(realloc(gcmt,(gcmt_max+1)*sizeof(void*))));
  }
  for (p=gcmt+(gcmt_used++ -1) ; (p>=gcmt)&&(*p>c) ; p--) {
    *(p+1) = *p;
  }
  *(p+1) = c;
}

static char*rso_from_store(na_env*nae,int size) {
  rsoh*r=(nae->store);
  nae->store_left-=size;
  if ((nae->store_left) > sizeof(rsoh)) {
    r->header.size=size;
    nae->store=((rsoh*)(((char*)(nae->store))+size));
  }
  else {
    r->header.size=size+nae->store_left;
    nae->store_left=0;
  }
  (r->header.magic_flag)=RSOH_UNMARKED;
  ((void)memset((r+1),0,r->header.size-sizeof(rsoh)));
  return (char*)(r+1);
}

static void rsoc_sweep(rsoc*c) {
  na_env*nae=c->nae;
  rsoh*gp=(rsoh*)&(c->first_header);
  rsoh*pp;
  rsoh*eoc=((rsoh*)(((char*)c)+c->header.size));
  c->free_list_of_large=NULL;
  if (c->header.size > RSOC_SIZE) {
    if (gp->header.magic_flag == RSOH_MARKED) {
      gp->header.magic_flag=RSOH_UNMARKED;
      c->next=nae->chunk_list;
      nae->chunk_list=c;
    }
    else {
      c->header.state_type=RSO_FREE_CHUNK;
    }
    return;
  }
  while (gp<eoc) {
    while (gp->header.magic_flag == RSOH_MARKED) {
      gp->header.magic_flag=RSOH_UNMARKED;
      gp=((rsoh*)(((char*)gp)+gp->header.size));
      if(gp>=eoc) {
	c->next=nae->chunk_list;
	nae->chunk_list=c;
	return;
      }
    }
    gp->header.magic_flag=RSOH_FREE;
    pp=(rsoh*)(((char*)gp)+gp->header.size);
    while ((pp<eoc)&&(pp->header.magic_flag != RSOH_MARKED)) {
      pp->header.magic_flag=RSOH_FREE;
      gp->header.size+=pp->header.size;
      pp=((rsoh*)(((char*)pp)+pp->header.size));
    }
    if (gp->header.size >= RSOC_MIN_STORE) {
      if (nae->store_left==0) {
	nae->store_left=gp->header.size;
	nae->store=gp;
	nae->store_chunk=c;
      }
      else if (nae->store->header.size < gp->header.size) {
	((fll_rsoh*)nae->store)->nextflol=nae->store_chunk->free_list_of_large;
	nae->store_chunk->free_list_of_large=((fll_rsoh*)nae->store);
	nae->store_left=gp->header.size;
	nae->store=gp;
	nae->store_chunk=c;
      }
      else {
	((fll_rsoh*)gp)->nextflol=c->free_list_of_large;
	c->free_list_of_large=((fll_rsoh*)gp);
      }
    }
    gp=pp;
  }
  if (((rsoh*)(&c->first_header))->header.size >=
      (c->header.size-sizeof(rsoc)+sizeof(rsoh))){
    c->header.state_type=RSO_FREE_CHUNK;
    nae->store_chunk=NULL;
    nae->store_left=0;
  }
  else{
    c->next=nae->chunk_list;
    nae->chunk_list=c;
  }
}

static const rsoc MRSOC = {
    {
	RSOC_SIZE,
	RSO_USED_CHUNK,
	((void(*)(mch*,void*))gcna_align_mark),
	((void(*)(mch*))rsoc_sweep)
    },
    0,
    NULL,
    NULL,
    NULL,
    {
      {
	0,
	RSOH_MARKED
      }
    }
};

static void rsoc_malloc(na_env*nae) {
  rsoc* r = ((rsoc*)(se_malloc(RSOC_SIZE)));
  rsoc_count++;
  *r=MRSOC;
  r->nae=nae;
  r->isize=RSOC_SIZE;
  nae->store=(&(r->first_header));
  nae->store_left=RSOC_SIZE-sizeof(rsoc)+sizeof(rsoh);
  nae->store_chunk=r;
  r->next=nae->chunk_list;
  nae->chunk_list=r;
  gc_add_into_gcmt((mch*)r);
}

static rsoc* rsocfl_best_fit(int size) {
  int best_size = 0;
  rsoc *pc,*best_pc,*best_c, *c;
  if (rsocfl==NULL)
    return NULL;
  pc=NULL;
  best_pc=NULL;
  best_c=NULL;
  c=rsocfl;
  while ((NULL!=c)&&(NULL==best_c)){
    if (c->header.size>=size){
      best_c=c;
      best_pc=pc;
      best_size=c->header.size;
    }
    pc=c;
    c=c->next;
  }
  if (NULL==c){
    if (best_pc != NULL)
      best_pc->next=best_c->next;
    else if (best_c==rsocfl)
      rsocfl=best_c->next;
    return best_c;
  }
  do {
    if ((c->header.size >= size) && (c->header.size < best_size)) {
      best_c = c;
      best_pc = pc;
      best_size = c->header.size;
    }
    pc=c;
    c=c->next;
  }
  while(c!=NULL);
  if (NULL==best_pc) {
    rsocfl = best_c->next;
  }
  else {
    best_pc->next=best_c->next;
  }
  return best_c;
}

static int get_store_in(rsoc*c,int size) {
  na_env*nae=c->nae;
  fll_rsoh*pf=NULL;
  fll_rsoh*f=c->free_list_of_large;
  while (f != NULL) {
    if (f->rsoh_field.size >= size) {
      nae->store_left=f->rsoh_field.size;
      nae->store=(rsoh*)f;
      nae->store_chunk=c;
      if (pf == NULL) {
	c->free_list_of_large=f->nextflol;
      }
      else {
	pf->nextflol=f->nextflol;
      }
      return 1;
    }
    pf = f;
    f = f->nextflol;
  }
  return 0;
}

char*new_na_from_chunk_list(na_env*nae,int size) {
  rsoc*c=nae->chunk_list;
  int csize;
  while (c != NULL) {
    if (get_store_in(c,size)) {
      return rso_from_store(nae,size);
    }
    c = c->next;
  }
  csize=size+(sizeof(rsoc)-sizeof(rsoh));
  c=rsocfl_best_fit(csize);
  if (c != NULL){
    if ((c->header.size > RSOC_SIZE)
	&&
	(c->header.size-csize > RSOC_MIN_STORE*4)) {
      int csize_left=c->header.size-csize;
      if ((csize_left%sizeof(double))!=0) {
	csize_left-=(csize_left%sizeof(double));
	csize=c->header.size-csize_left;
      }
      c->header.size=csize_left;
      c->next=rsocfl;
      rsocfl=c;
      c=(rsoc*)(((char*)c)+csize_left);
      gc_add_into_gcmt((mch*)c);
      c->header.amfp=(void(*)(mch*,void*))gcna_align_mark;
      c->header.swfp=(void(*)(mch*))rsoc_sweep;
    }
    else {
      csize=c->header.size;
    }
    c->header.size=csize;
    c->header.state_type=RSO_USED_CHUNK;
    c->free_list_of_large=NULL;
    c->nae=nae;
    nae->store=(&(c->first_header));
    nae->store_left=csize-sizeof(rsoc)+sizeof(rsoh);
    nae->store_chunk=c;
    c->next=nae->chunk_list;
    nae->chunk_list=c;
    return rso_from_store(nae,size);
  }
  return NULL;
}

char*new_na(na_env*nae,int size) {
  if (nae->store_left>0) {
    nae->store->header.size=nae->store_left;
    nae->store->header.magic_flag=RSOH_FREE;
    if (nae->store_left >= RSOC_MIN_STORE) {
      ((fll_rsoh*)(nae->store))->nextflol=nae->store_chunk->free_list_of_large;
      nae->store_chunk->free_list_of_large=((fll_rsoh*)nae->store);
    }
    nae->store_left=0;
  }
  if ((nae->store_chunk!=NULL)&&(get_store_in(nae->store_chunk,size))) {
    return rso_from_store(nae,size);
  }
  {
    char*r=new_na_from_chunk_list(nae,size);
    if (r!=NULL)
      return r;
  }
  if (rsoc_count<rsoc_count_ceil) {
    if((size+sizeof(rsoc)-sizeof(rsoh))>RSOC_SIZE){
      rsoc*c;
      rsoh*r;
      int rounded_size = chunk_rounded(size+sizeof(rsoc)-sizeof(rsoh));
      c=((rsoc*)(se_malloc(rounded_size)));
      r=(&(c->first_header));
      rsoc_count++;
      *c=MRSOC;
      c->isize = rounded_size;
      c->header.size=rounded_size;
      c->nae=nae;
      c->next=nae->chunk_list;
      nae->chunk_list=c;
      gc_add_into_gcmt((mch*)c);
      r->header.size=size;
      (r->header.magic_flag)=RSOH_UNMARKED;
      ((void)memset((r+1),0,size-sizeof(rsoh)));
      return (char*)(r+1);
    }
    else {
      rsoc_malloc(nae);
      return rso_from_store(nae,size);
    }
  }
  gc_start();
  if (size<=(nae->store_left)) {
    return rso_from_store(nae,size);
  }
  {
    char*r=new_na_from_chunk_list(nae,size);
    if (r!=NULL) {
      return r;
    }
  }
  if((size+sizeof(rsoc)-sizeof(rsoh))>RSOC_SIZE){
    rsoc*c;
    rsoh*r;
    int rounded_size = chunk_rounded(size+sizeof(rsoc)-sizeof(rsoh));
    c=((rsoc*)(se_malloc(rounded_size)));
    r=(&(c->first_header));
    rsoc_count++;
    *c=MRSOC;
    c->isize = rounded_size;
    c->header.size=rounded_size;
    c->nae=nae;
    c->next=nae->chunk_list;
    nae->chunk_list=c;
    gc_add_into_gcmt((mch*)c);
    r->header.size=size;
    (r->header.magic_flag)=RSOH_UNMARKED;
    ((void)memset((r+1),0,size-sizeof(rsoh)));
    gc_update_ceils();
    return (char*)(r+1);
  }
  else {
    rsoc_malloc(nae);
    gc_update_ceils();
    return rso_from_store(nae,size);
  }
}

static void gcna_align_mark(rsoc*c,void*o) {
  na_env* nae = c->nae;
  fll_rsoh* f;
  fll_rsoh* pf;
  char* b = (char*)&(c->first_header);
  /* out of the chunck 'c' ? */
  if (((char*)o) > (((char*)c)+c->header.size)) {
      return;
  }
  /* properly aligned ? */
  if (((((char*)o)-((char*)c))%sizeof(int)) != 0) {
      return;
  }
  /* already marked ? */
  if ((((rsoh*)o)-1)->header.magic_flag != RSOH_UNMARKED) {
      return;
  }
  if (((char*)o) < ((char*)(c+1))) {
      return;
  }
  /* a large chunck ? */
  if (c->header.size > RSOC_SIZE) {
      if (o == (c+1)) {
	nae->gc_mark((T0*)o);
      }
      return;
  }
  pf=NULL;
  f=c->free_list_of_large;
  while ((f != NULL) && (f < ((fll_rsoh*)o))) {
      pf=f;
      f=f->nextflol;
  }
  if (pf == NULL) {
      pf=(fll_rsoh*)b;
  }
  while ((((rsoh*)pf)+1) < (rsoh*)o) {
      pf = ((fll_rsoh*)(((char*)pf)+pf->rsoh_field.size));
  }
  if (o == (((rsoh*)pf)+1)) {
    nae->gc_mark((T0*)o);
  }
}

int rsocfl_count(void) {
  /* Returns the number of items in the ReSizable Object Free List.
  */
  int r=0;
  rsoc*p=rsocfl;
  while (p!=NULL) {
    r++;
    p=p->next;
  }
  return r;
}

int fsocfl_count(void) {
  int r=0;
  fsoc*p=fsocfl;
  while (p!=NULL) {
    r++;
    p=p->next;
  }
  return r;
}

void gc_dispose_before_exit(void) {
  mch** p = gcmt;
  mch**eogcmt=gcmt+gcmt_used;

  while (p < eogcmt) {
    if (((*p)->state_type == FSO_STORE_CHUNK) ||
	((*p)->state_type == FSO_USED_CHUNK)) {
      ((*p)->swfp)(*p);
    }
    p++;
  }
}

fsoc* gc_fsoc_get1(void) {
  /* Get a `fsoc' (Fixed Size Object Chunk) from the free fsoc list or
     allocate a new one (using `se_malloc') only when the ceil is not
     yet reached. Otherwise, call the `gc_start()' function and
     return NULL.
  */
  fsoc* result;
  if (fsocfl != NULL) {
    result = fsocfl;
    fsocfl = fsocfl->next;
    return result;
  }
  else if (fsoc_count_ceil > fsoc_count) {
    result = ((fsoc*)se_malloc(FSOC_SIZE));
    fsoc_count++;
    gc_add_into_gcmt((mch*)result);
    return result;
  }
  else {
    gc_start();
    return NULL;
  }
}

fsoc* gc_fsoc_get2(void) {
  /* Get a `fsoc' (Fixed Size Object Chunk) or force the allocation of a
     new `fsoc' (using the `se_malloc' function). Update various ceils
     accordingly.
  */
  fsoc* result;
  if (fsocfl != NULL) {
    result = fsocfl;
    fsocfl=fsocfl->next;
    return result;
  }
  else {
    result = ((fsoc*)(se_malloc(FSOC_SIZE)));
    gc_update_ceils();
    fsoc_count++;
    gc_add_into_gcmt((mch*)result);
    return result;
  }
}
/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of
-- another product.
--       Copyright (C) 1994-2002 LORIA - INRIA - U.H.P. Nancy 1 - FRANCE
--          Dominique COLNET and Suzanne COLLIN - SmallEiffel@loria.fr
--                       http://SmallEiffel.loria.fr
--
*/
/*
  This file (SmallEiffel/sys/runtime/basic_sprintf.c) is automatically
  included when the external "SmallEiffel" basic_sprintf feature is used.
*/

void basic_sprintf_double(EIF_CHARACTER* b, int f, double d) {
  char fmt[32];
  fmt[0]='%';
  fmt[1]='.';
  sprintf(fmt+2,"%df",f);
  sprintf(b,fmt,d);
}
unsigned int fsoc_count_ceil=468;
unsigned int rsoc_count_ceil=69;
T0*oBC8string_buffer=NULL;

T2 r8hash_code(T8 C){
T2 R=0;
T9 _storage=NULL;
_storage=(/*RF2*/((T7*)(oBC8string_buffer))->_storage/*4*/);
{void*p=C;
sprintf(((char*)_storage),"%p",p);}
r7from_external((T7*)(oBC8string_buffer),((void*)(_storage)));
R=r7hash_code((T7*)(oBC8string_buffer));
return R;
}

T6 r6_ix_not(T6 C){
T6 R=0;
/*[IF*/
if(C){
}
else{
R=1;
}
/*FI]*/
return R;
}

T6 r3_px_6061(T3 C,T3 a1){
T6 R=0;
R=(T3code(C))<=(T3code(a1));
return R;
}

T6 r3is_digit(T3 C){
T6 R=0;
/*[IF*/
if((((unsigned)(C))>=((unsigned)(((T3)'0'))))){
R=(((unsigned)(C))<=((unsigned)(((T3)'9'))));
}
/*FI]*/
return R;
}

T6 r3is_hexadecimal_digit(T3 C){
T6 R=0;
/*[IF*/
if(r3is_digit(C)){
R=1;
}
 else if((((unsigned)(C))>=((unsigned)(((T3)'a'))))){
R=(((unsigned)(C))<=((unsigned)(((T3)'f'))));
}
 else if((((unsigned)(C))>=((unsigned)(((T3)'A'))))){
R=(((unsigned)(C))<=((unsigned)(((T3)'F'))));
}
/*FI]*/
return R;
}

T6 r3_px_6261(T3 C,T3 a1){
T6 R=0;
R=(T3code(C))>=(T3code(a1));
return R;
}

T2 r3value(T3 C){
T2 R=0;
R=(T3code(C))-(48);
return R;
}

T2 r3hexadecimal_value(T3 C){
T2 R=0;
/*[IF*/
if((T3code(C))<(T3code(((T3)'A')))){
R=(T3code(C))-(48);
}
 else if((T3code(C))<(T3code(((T3)'a')))){
R=(T3code(C))-(55);
}
else{
R=(T3code(C))-(87);
}
/*FI]*/
return R;
}

T6 r2is_equal(T2 C,T2 a1){
T6 R=0;
R=(!((C)<(a1)))&&(!((a1)<(C)));
return R;
}

T0* r2to_string(T2 C){
T0* R=NULL;
/*[IRF3.3clear*/((((T7*)((T7*)(oBC2tmp_string))))->_count/*8*/)=(0);
/*]*/
r2append_in(C,oBC2tmp_string);
R=r7twin((T7*)(oBC2tmp_string));
return R;
}
T0*oBC2tmp_string=NULL;

T3 r2digit(T2 C){
T3 R=0;
R=((T3)((C)+(T3code(((T3)'0')))));
return R;
}

T2 r2hash_code(T2 C){
T2 R=0;
/*[IF*/
if((C)<(0)){
R=-((C)+(1));
}
else{
R=C;
}
/*FI]*/
return R;
}

void r2append_in(T2 C,T0* a1){
T2 _val=0;
T2 _i=0;
/*[IF*/
if((C)==(0)){
r7extend(((T7*)a1),((T3)'0'));
}
else{
/*[IF*/
if((C)>(0)){
_i=((/*RF2*/(((T7*)a1))->_count/*8*/))+(1);
_val=C;
while (!((_val)==(0)))
{
r7extend(((T7*)a1),r2digit((_val)%(10)));
_val=(_val)/(10);
}
}
else{
r7extend(((T7*)a1),((T3)'\55'));
_i=((/*RF2*/(((T7*)a1))->_count/*8*/))+(1);
_val=C;
while (!((_val)==(0)))
{
r7extend(((T7*)a1),r2digit(-((_val)%(10))));
_val=(_val)/(10);
}
}
/*FI]*/
_val=(/*RF2*/(((T7*)a1))->_count/*8*/);
while (!((_i)>=(_val)))
{
r7swap(((T7*)a1),_i,_val);
_val=(_val)-(1);
_i=(_i)+(1);
}
}
/*FI]*/
}

T3 r2hexadecimal_digit(T2 C){
T3 R=0;
/*[IF*/
if((C)<=(9)){
R=r2digit(C);
}
else{
R=((T3)((T3code(((T3)'A')))+((C)-(10))));
}
/*FI]*/
return R;
}
T9 oBC5sprintf_buffer=NULL;
int fBC5sprintf_buffer=0;

T9 r5sprintf_buffer(void){
if(fBC5sprintf_buffer==0){fBC5sprintf_buffer=1;{
oBC5sprintf_buffer=new9(1024);
}}
return oBC5sprintf_buffer;
}

T2 r5sign(T5 C){
T2 R=0;
/*[IF*/
if(((/*RF2*/C))<(T4toT5(0.0))){
R=-(1);
}
 else if(((/*RF2*/C))>(T4toT5(0.0))){
R=1;
}
/*FI]*/
return R;
}

T0* r5to_string(T5 C){
T0* R=NULL;
{T7*n=new7();
r7make(n,8);
R=((T0*)n);
}
/*[IRF3.6append_in*/{T5 C1=C;
T0* b1=R;
r5append_in_format(C1,b1,6);
}/*]*/
return R;
}

T5 r5double_ceiling(T5 C){
T5 R=0;
R=ceil(C);
return R;
}

T2 r5rounded(T5 C){
T2 R=0;
/*[IF*/
if(((floor(C))+(T4toT5(0.5)))<(C)){
R=((int)floor(r5double_ceiling(C)));
}
else{
R=((int)floor(floor(C)));
}
/*FI]*/
return R;
}

void r5append_in_format(T5 C,T0* a1,T2 a2){
T2 _i=0;
basic_sprintf_double(r5sprintf_buffer(),a2,C);
_i=0;
while (!(((r5sprintf_buffer())[_i])==(((T3)'\0'))))
{
r7extend(((T7*)a1),(r5sprintf_buffer())[_i]);
_i=(_i)+(1);
}
}

T5 r4pow(T4 C,T5 a1){
T5 R=0;
R=pow(((T5)(C)),a1);
return R;
}

T0* r4to_string(T4 C){
T0* R=NULL;
R=r5to_string(((T5)(C)));
return R;
}

T2 r4rounded(T4 C){
T2 R=0;
R=r5rounded(((T5)(C)));
return R;
}

T5 r4atan(T4 C){
T5 R=0;
R=atan(((T5)(C)));
return R;
}

void r160set_all_with(T160 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}

void r160copy_from(T160 C,T160 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}

void r152set_all_with(T152 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}

void r152copy_from(T152 C,T152 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}

void r164set_all_with(T164 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}

void r142set_all_with(T142 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}

void r142copy_from(T142 C,T142 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}

void r182set_all_with(T182 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}

void r182copy_from(T182 C,T182 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}

void r119set_all_with(T119 C,T5 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}

void r119copy_from(T119 C,T119 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}

void r155set_all_with(T155 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}

void r155copy_from(T155 C,T155 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}

void r58set_all_with(T58 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}

void r100set_all_with(T100 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}

void r145set_all_with(T145 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}

void r145copy_from(T145 C,T145 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}

void r194clear_all(T194 C,T2 a1){
T0* _v=NULL;
T2 _i=0;
_i=a1;
while (!((_i)<(0)))
{
(C)[_i]=(_v);
_i=(_i)-(1);
}
}

void r194set_all_with(T194 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}

void r194copy_from(T194 C,T194 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}

void r187set_all_with(T187 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}

void r187copy_from(T187 C,T187 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}

void r79set_all_with(T79 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}

void r190set_all_with(T190 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}

T9 r9realloc(T9 C,T2 a1,T2 a2){
T9 R=NULL;
R=new9(a2);
r9copy_from(R,C,(a1)-(1));
return R;
}

void r9set_all_with(T9 C,T3 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}

T6 r9fast_memcmp(T9 C,T9 a1,T2 a2){
T6 R=0;
T2 _i=0;
_i=(a2)-(1);
while (!(((_i)<(0))||(((C)[_i])!=((a1)[_i]))))
{
_i=(_i)-(1);
}
R=(_i)<(0);
return R;
}

void r9copy_at(T9 C,T2 a1,T9 a2,T2 a3){
T2 _at_idx=0;
T2 _src_idx=0;
_src_idx=(a3)-(1);
_at_idx=(a1)+(_src_idx);
while (!((_src_idx)<(0)))
{
(C)[_at_idx]=((a2)[_src_idx]);
_src_idx=(_src_idx)-(1);
_at_idx=(_at_idx)-(1);
}
}

void r9copy_from(T9 C,T9 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}

void r63set_all_with(T63 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}

void r202set_all_with(T202 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}

void r46set_all_with(T46 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}

void r157set_all_with(T157 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}

void r157copy_from(T157 C,T157 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}

void r148set_all_with(T148 C,T2 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}

void r148copy_from(T148 C,T148 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}

void r7copy(T7* C,T0* a1){
T2 _c=0;
_c=(/*RF2*/(((T7*)a1))->_count/*8*/);
/*[IF*/
if((_c)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*12*/))<(_c)){
(/*SFN*/C->_storage/*4*/)=new9(_c);
(/*SFN*/C->_capacity/*12*/)=_c;
}
/*FI]*/
r9copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T7*)a1))->_storage/*4*/),(_c)-(1));
}
/*FI]*/
(/*SFN*/C->_count/*8*/)=_c;
}

T6 r7is_equal(T7* C,T0* a1){
T6 R=0;
/*[IF*/
if(((/*RF2*/(C)->_count/*8*/))==((/*RF2*/(((T7*)a1))->_count/*8*/))){
R=r9fast_memcmp((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T7*)a1))->_storage/*4*/),(/*RF2*/(C)->_count/*8*/));
}
/*FI]*/
return R;
}

void r7append(T7* C,T0* a1){
T2 _s_count=0;
T2 _needed_capacity=0;
T2 _new_capacity=0;
_s_count=(/*RF2*/(((T7*)a1))->_count/*8*/);
_needed_capacity=((/*RF2*/(C)->_count/*8*/))+(_s_count);
/*[IF*/
if((_needed_capacity)>((/*RF2*/(C)->_capacity/*12*/))){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*12*/))==(0)){
(/*SFN*/C->_storage/*4*/)=new9(_needed_capacity);
(/*SFN*/C->_capacity/*12*/)=_needed_capacity;
}
else{
_new_capacity=(2)*((/*RF2*/(C)->_capacity/*12*/));
/*[IF*/
if((_needed_capacity)>(_new_capacity)){
(/*SFN*/C->_storage/*4*/)=r9realloc((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(C)->_capacity/*12*/),_needed_capacity);
(/*SFN*/C->_capacity/*12*/)=_needed_capacity;
}
else{
(/*SFN*/C->_storage/*4*/)=r9realloc((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(C)->_capacity/*12*/),_new_capacity);
(/*SFN*/C->_capacity/*12*/)=_new_capacity;
}
/*FI]*/
}
/*FI]*/
}
/*FI]*/
r9copy_at((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(C)->_count/*8*/),(/*RF2*/(((T7*)a1))->_storage/*4*/),_s_count);
(/*SFN*/C->_count/*8*/)=_needed_capacity;
}

void r7make(T7* C,T2 a1){
/*[IF*/
if((a1)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*12*/))<(a1)){
(/*SFN*/C->_storage/*4*/)=new9(a1);
(/*SFN*/C->_capacity/*12*/)=a1;
}
/*FI]*/
}
/*FI]*/
(/*SFN*/C->_count/*8*/)=0;
}

void r7extend(T7* C,T3 a1){
T2 _new_capacity=0;
/*[IF*/
if(((/*RF2*/(C)->_capacity/*12*/))>((/*RF2*/(C)->_count/*8*/))){
}
 else if(((/*RF2*/(C)->_capacity/*12*/))==(0)){
_new_capacity=32;
(/*SFN*/C->_storage/*4*/)=new9(_new_capacity);
(/*SFN*/C->_capacity/*12*/)=_new_capacity;
}
else{
_new_capacity=(2)*((/*RF2*/(C)->_capacity/*12*/));
(/*SFN*/C->_storage/*4*/)=r9realloc((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(C)->_capacity/*12*/),_new_capacity);
(/*SFN*/C->_capacity/*12*/)=_new_capacity;
}
/*FI]*/
((/*RF2*/(C)->_storage/*4*/))[(/*RF2*/(C)->_count/*8*/)]=(a1);
(/*SFN*/C->_count/*8*/)=((/*RF2*/(C)->_count/*8*/))+(1);
}

T0* r7_px_43(T7* C,T0* a1){
T0* R=NULL;
{T7*n=new7();
r7make(n,((/*RF2*/(C)->_count/*8*/))+((/*RF2*/(((T7*)a1))->_count/*8*/)));
R=((T0*)n);
}
r7append(((T7*)R),(T0*)C);
r7append(((T7*)R),a1);
return R;
}

T2 r7hash_code(T7* C){
T2 R=0;
T2 _i=0;
T2 _j=0;
_j=(/*RF2*/(C)->_count/*8*/);
_i=1;
while (!((_j)<=(0)))
{
R=((5)*(R))+(T3code(/*(IRF4.6item*/((/*RF2*/(C)->_storage/*4*/))[(_i)-(1)]/*)*/));
_i=(_i)+(1);
_j=(_j)-(1);
}
/*[IF*/
if((R)<(0)){
R=-((R)+(1));
}
/*FI]*/
return R;
}

void r7remove_last(T7* C,T2 a1){
/*[IF*/
if((a1)>((/*RF2*/(C)->_count/*8*/))){
(/*SFN*/C->_count/*8*/)=0;
}
else{
(/*SFN*/C->_count/*8*/)=((/*RF2*/(C)->_count/*8*/))-(a1);
}
/*FI]*/
}

void r7append_character(T7* C,T3 a1){
T2 _new_capacity=0;
/*[IF*/
if(((/*RF2*/(C)->_capacity/*12*/))>((/*RF2*/(C)->_count/*8*/))){
}
 else if(((/*RF2*/(C)->_capacity/*12*/))==(0)){
_new_capacity=32;
(/*SFN*/C->_storage/*4*/)=new9(_new_capacity);
(/*SFN*/C->_capacity/*12*/)=_new_capacity;
}
else{
_new_capacity=(2)*((/*RF2*/(C)->_capacity/*12*/));
(/*SFN*/C->_storage/*4*/)=r9realloc((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(C)->_capacity/*12*/),_new_capacity);
(/*SFN*/C->_capacity/*12*/)=_new_capacity;
}
/*FI]*/
((/*RF2*/(C)->_storage/*4*/))[(/*RF2*/(C)->_count/*8*/)]=(a1);
(/*SFN*/C->_count/*8*/)=((/*RF2*/(C)->_count/*8*/))+(1);
}

void r7add_last(T7* C,T3 a1){
T2 _new_capacity=0;
/*[IF*/
if(((/*RF2*/(C)->_capacity/*12*/))>((/*RF2*/(C)->_count/*8*/))){
}
 else if(((/*RF2*/(C)->_capacity/*12*/))==(0)){
_new_capacity=32;
(/*SFN*/C->_storage/*4*/)=new9(_new_capacity);
(/*SFN*/C->_capacity/*12*/)=_new_capacity;
}
else{
_new_capacity=(2)*((/*RF2*/(C)->_capacity/*12*/));
(/*SFN*/C->_storage/*4*/)=r9realloc((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(C)->_capacity/*12*/),_new_capacity);
(/*SFN*/C->_capacity/*12*/)=_new_capacity;
}
/*FI]*/
((/*RF2*/(C)->_storage/*4*/))[(/*RF2*/(C)->_count/*8*/)]=(a1);
(/*SFN*/C->_count/*8*/)=((/*RF2*/(C)->_count/*8*/))+(1);
}

void r7from_external(T7* C,T8 a1){
(/*SFN*/C->_storage/*4*/)=a1;
(/*SFN*/C->_count/*8*/)=0;
while (!((((/*RF2*/(C)->_storage/*4*/))[(/*RF2*/(C)->_count/*8*/)])==(((T3)'\0'))))
{
(/*SFN*/C->_count/*8*/)=((/*RF2*/(C)->_count/*8*/))+(1);
}
(/*SFN*/C->_capacity/*12*/)=((/*RF2*/(C)->_count/*8*/))+(1);
}

T8 r7to_external(T7* C){
T8 R=NULL;
/*[IF*/
if(((/*RF2*/(C)->_capacity/*12*/))>((/*RF2*/(C)->_count/*8*/))){
(/*SFN*/C->_count/*8*/)=((/*RF2*/(C)->_count/*8*/))+(1);
/*[IF*/
if((/*(IRF4.6item*/((/*RF2*/(C)->_storage/*4*/))[((/*RF2*/(C)->_count/*8*/))-(1)]/*)*/)!=(((T3)'\0'))){
/*[IRF3.5put*/((/*RF2*/(C)->_storage/*4*/))[((/*RF2*/(C)->_count/*8*/))-(1)]=(((T3)'\0'));
/*]*/
}
/*FI]*/
}
else{
r7append_character(C,((T3)'\0'));
}
/*FI]*/
(/*SFN*/C->_count/*8*/)=((/*RF2*/(C)->_count/*8*/))-(1);
R=((void*)((/*RF2*/(C)->_storage/*4*/)));
return R;
}

T0* r7twin(T7* C){
T0* R=NULL;
R=((void*)new7());
r7copy(((T7*)R),((T0*)C));
return R;
}

void r7swap(T7* C,T2 a1,T2 a2){
T3 _tmp=0;
_tmp=/*(IRF4.6item*/((/*RF2*/(C)->_storage/*4*/))[(a1)-(1)]/*)*/;
/*[IRF3.5put*/((/*RF2*/(C)->_storage/*4*/))[(a1)-(1)]=(/*(IRF4.6item*/((/*RF2*/(C)->_storage/*4*/))[(a2)-(1)]/*)*/);
/*]*/
/*[IRF3.5put*/((/*RF2*/(C)->_storage/*4*/))[(a2)-(1)]=(_tmp);
/*]*/
}

void r134copy(T134* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T134*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T134*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_storage/*4*/)=new157(_needed_capacity);
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r157copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T134*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}

T2 r134count(T134* C){
T2 R=0;
R=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
return R;
}

T0* r134item(T134* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}

void r134make(T134* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new157(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
/*[IRF3.6clear_all*/{T134* C1=C;
T0* __value=NULL;
/*[IRF3.6set_all_with*/{T134* C2=C1;
T0* c1=__value;
r157set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,((/*RF2*/(C2)->_upper/*12*/))-((/*RF2*/(C2)->_lower/*16*/)));
}/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}

T0* r134twin(T134* C){
T0* R=NULL;
R=((void*)new134());
r134copy(((T134*)R),((T0*)C));
return R;
}

void r146copy(T146* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T146*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T146*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_storage/*4*/)=new148(_needed_capacity);
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r148copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T146*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}

T2 r146count(T146* C){
T2 R=0;
R=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
return R;
}

T2 r146item(T146* C,T2 a1){
T2 R=0;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}

void r146make(T146* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new148(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
/*[IRF3.6clear_all*/{T146* C1=C;
T2 __value=0;
/*[IRF3.6set_all_with*/{T146* C2=C1;
T2 c1=__value;
r148set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,((/*RF2*/(C2)->_upper/*12*/))-((/*RF2*/(C2)->_lower/*16*/)));
}/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}

T2 r146_px_64(T146* C,T2 a1){
T2 R=0;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}

T0* r146twin(T146* C){
T0* R=NULL;
R=((void*)new146());
r146copy(((T146*)R),((T0*)C));
return R;
}

void r146swap(T146* C,T2 a1,T2 a2){
T2 _tmp=0;
_tmp=r146item(C,a1);
/*[IRF3.6put*/{T146* C1=C;
T2 b1=r146item(C,a2);
T2 b2=a1;
((/*RF2*/(C1)->_storage/*4*/))[(b2)-((/*RF2*/(C1)->_lower/*16*/))]=(b1);
}/*]*/
/*[IRF3.6put*/{T146* C1=C;
T2 b1=_tmp;
T2 b2=a2;
((/*RF2*/(C1)->_storage/*4*/))[(b2)-((/*RF2*/(C1)->_lower/*16*/))]=(b1);
}/*]*/
}

void r140copy(T140* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T140*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T140*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_storage/*4*/)=new142(_needed_capacity);
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r142copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T140*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}

void r140make(T140* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new142(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
/*[IRF3.6clear_all*/{T140* C1=C;
T0* __value=NULL;
/*[IRF3.6set_all_with*/{T140* C2=C1;
T0* c1=__value;
r142set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,((/*RF2*/(C2)->_upper/*12*/))-((/*RF2*/(C2)->_lower/*16*/)));
}/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}

T0* r140_px_64(T140* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}

T0* r140twin(T140* C){
T0* R=NULL;
R=((void*)new140());
r140copy(((T140*)R),((T0*)C));
return R;
}

void r180copy(T180* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T180*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T180*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_storage/*4*/)=new182(_needed_capacity);
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r182copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T180*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}

T0* r180item(T180* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}

void r180make(T180* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new182(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
/*[IRF3.6clear_all*/{T180* C1=C;
T0* __value=NULL;
/*[IRF3.6set_all_with*/{T180* C2=C1;
T0* c1=__value;
r182set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,((/*RF2*/(C2)->_upper/*12*/))-((/*RF2*/(C2)->_lower/*16*/)));
}/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}

T0* r180_px_64(T180* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}

T0* r180twin(T180* C){
T0* R=NULL;
R=((void*)new180());
r180copy(((T180*)R),((T0*)C));
return R;
}

void r185copy(T185* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T185*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T185*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_storage/*4*/)=new187(_needed_capacity);
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r187copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T185*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}

void r185make(T185* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new187(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
/*[IRF3.6clear_all*/{T185* C1=C;
T0* __value=NULL;
/*[IRF3.6set_all_with*/{T185* C2=C1;
T0* c1=__value;
r187set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,((/*RF2*/(C2)->_upper/*12*/))-((/*RF2*/(C2)->_lower/*16*/)));
}/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}

T0* r185_px_64(T185* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}

T0* r185twin(T185* C){
T0* R=NULL;
R=((void*)new185());
r185copy(((T185*)R),((T0*)C));
return R;
}

void r153copy(T153* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T153*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T153*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_storage/*4*/)=new155(_needed_capacity);
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r155copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T153*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}

T0* r153item(T153* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}

void r153make(T153* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new155(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
/*[IRF3.6clear_all*/{T153* C1=C;
T0* __value=NULL;
/*[IRF3.6set_all_with*/{T153* C2=C1;
T0* c1=__value;
r155set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,((/*RF2*/(C2)->_upper/*12*/))-((/*RF2*/(C2)->_lower/*16*/)));
}/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}

T0* r153_px_64(T153* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}

T0* r153twin(T153* C){
T0* R=NULL;
R=((void*)new153());
r153copy(((T153*)R),((T0*)C));
return R;
}

void r197copy(T197* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T197*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T197*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_storage/*4*/)=new9(_needed_capacity);
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r9copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T197*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}

T3 r197item(T197* C,T2 a1){
T3 R=0;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}

void r197make(T197* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new9(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
/*[IRF3.6clear_all*/{T197* C1=C;
T3 __value=0;
/*[IRF3.6set_all_with*/{T197* C2=C1;
T3 c1=__value;
r9set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,((/*RF2*/(C2)->_upper/*12*/))-((/*RF2*/(C2)->_lower/*16*/)));
}/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}

T0* r197twin(T197* C){
T0* R=NULL;
R=((void*)new197());
r197copy(((T197*)R),((T0*)C));
return R;
}

void r158copy(T158* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T158*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T158*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_storage/*4*/)=new160(_needed_capacity);
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r160copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T158*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}

T0* r158item(T158* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}

void r158make(T158* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new160(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
/*[IRF3.6clear_all*/{T158* C1=C;
T0* __value=NULL;
/*[IRF3.6set_all_with*/{T158* C2=C1;
T0* c1=__value;
r160set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,((/*RF2*/(C2)->_upper/*12*/))-((/*RF2*/(C2)->_lower/*16*/)));
}/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}

T0* r158twin(T158* C){
T0* R=NULL;
R=((void*)new158());
r158copy(((T158*)R),((T0*)C));
return R;
}

void r143copy(T143* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T143*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T143*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_storage/*4*/)=new145(_needed_capacity);
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r145copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T143*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}

T0* r143item(T143* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}

void r143make(T143* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new145(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
/*[IRF3.6clear_all*/{T143* C1=C;
T0* __value=NULL;
/*[IRF3.6set_all_with*/{T143* C2=C1;
T0* c1=__value;
r145set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,((/*RF2*/(C2)->_upper/*12*/))-((/*RF2*/(C2)->_lower/*16*/)));
}/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}

T0* r143twin(T143* C){
T0* R=NULL;
R=((void*)new143());
r143copy(((T143*)R),((T0*)C));
return R;
}

void r150copy(T150* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T150*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T150*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_storage/*4*/)=new152(_needed_capacity);
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r152copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T150*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}

T0* r150item(T150* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}

void r150make(T150* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new152(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
/*[IRF3.6clear_all*/{T150* C1=C;
T0* __value=NULL;
/*[IRF3.6set_all_with*/{T150* C2=C1;
T0* c1=__value;
r152set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,((/*RF2*/(C2)->_upper/*12*/))-((/*RF2*/(C2)->_lower/*16*/)));
}/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}

T0* r150twin(T150* C){
T0* R=NULL;
R=((void*)new150());
r150copy(((T150*)R),((T0*)C));
return R;
}

void r195copy(T195* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T195*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T195*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_storage/*4*/)=new194(_needed_capacity);
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r194copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T195*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}

T2 r195count(T195* C){
T2 R=0;
R=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
return R;
}

T0* r195item(T195* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}

void r195make(T195* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new194(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
/*[IRF3.6clear_all*/{T195* C1=C;
T0* __value=NULL;
/*[IRF3.6set_all_with*/{T195* C2=C1;
T0* c1=__value;
r194set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,((/*RF2*/(C2)->_upper/*12*/))-((/*RF2*/(C2)->_lower/*16*/)));
}/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}

T0* r195_px_64(T195* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}

T0* r195twin(T195* C){
T0* R=NULL;
R=((void*)new195());
r195copy(((T195*)R),((T0*)C));
return R;
}

void r118copy(T118* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=/*SSWARF2*//*X118lower*/(/*RF2*/(((T118*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=/*SSWARF2*//*X118upper*/(/*RF2*/(((T118*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_storage/*4*/)=new119(_needed_capacity);
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r119copy_from((/*RF2*/(C)->_storage/*4*/),/*SSWARF2*//*X118storage*/((T119)((/*RF2*/(((T118*)a1))->_storage/*4*/))),(_needed_capacity)-(1));
}
/*FI]*/
}

void r118clear_all(T118* C){
T5 _value=0;
/*[IRF3.6set_all_with*/{T118* C1=C;
T5 b1=_value;
r119set_all_with((/*RF2*/(C1)->_storage/*4*/),b1,((/*RF2*/(C1)->_upper/*12*/))-((/*RF2*/(C1)->_lower/*16*/)));
}/*]*/
}

T5 r118item(T118* C,T2 a1){
T5 R=0;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}

void r118make(T118* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new119(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
r118clear_all(C);
}
/*FI]*/
}
/*FI]*/
}

T5 r118_px_64(T118* C,T2 a1){
T5 R=0;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}

T0* r118twin(T118* C){
T0* R=NULL;
R=((void*)new118());
r118copy(((T118*)R),((T0*)C));
return R;
}

void r218next(T218* C){
(/*SFN*/C->_item_index/*8*/)=((/*RF2*/(C)->_item_index/*8*/))+(1);
}

T0* r218item(T218* C){
T0* R=NULL;
R=r200item((T200*)((/*RF2*/(C)->_dictionary/*4*/)),(/*RF2*/(C)->_item_index/*8*/));
return R;
}

void r218make(T218* C,T0* a1){
(/*SFN*/C->_dictionary/*4*/)=a1;
(/*SFN*/C->_item_index/*8*/)=1;
}

T6 r218is_off(T218* C){
T6 R=0;
R=((/*RF2*/(C)->_item_index/*8*/))>((/*RF2*/((T200*)((/*RF2*/(C)->_dictionary/*4*/)))->_count/*12*/));
return R;
}

T0* r218twin(T218* C){
T0* R=NULL;
R=((void*)new218());
*((T218*)R)=*C;
return R;
}

void r189make(T189* C,T0* a1,T2 a2,T0* a3){
(/*SFN*/C->_item/*4*/)=a1;
(/*SFN*/C->_key/*8*/)=a2;
(/*SFN*/C->_next/*12*/)=a3;
}

T0* r189twin(T189* C){
T0* R=NULL;
R=((void*)new189());
*((T189*)R)=*C;
return R;
}

void r114next(T114* C){
(/*SFN*/C->_current_link/*8*/)=(/*RF2*/((T82*)((/*RF2*/(C)->_current_link/*8*/)))->_next/*8*/);
}

void r114make(T114* C,T0* a1){
(/*SFN*/C->_linked_list/*4*/)=a1;
(/*SFN*/C->_current_link/*8*/)=(/*RF2*/((T81*)((/*RF2*/(C)->_linked_list/*4*/)))->_first_link/*8*/);
}

void r114start(T114* C){
(/*SFN*/C->_current_link/*8*/)=(/*RF2*/((T81*)((/*RF2*/(C)->_linked_list/*4*/)))->_first_link/*8*/);
}

T0* r114twin(T114* C){
T0* R=NULL;
R=((void*)new114());
*((T114*)R)=*C;
return R;
}

void r43copy(T43* C,T0* a1){
T2 _i=0;
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))==(0)){
r43with_capacity(C,((/*RF2*/(((T43*)a1))->_count/*12*/))+(1));
}
else{
r43clear(C);
}
/*FI]*/
_i=1;
while (!((_i)>((/*RF2*/(((T43*)a1))->_count/*12*/))))
{
r43put(C,r43item(((T43*)a1),_i),r43key(((T43*)a1),_i));
_i=(_i)+(1);
}
}

T0* r43key(T43* C,T2 a1){
T0* R=NULL;
r43set_cache_user(C,a1);
R=(/*RF2*/((T45*)((/*RF2*/(C)->_cache_node/*20*/)))->_key/*8*/);
return R;
}

T0* r43at(T43* C,T0* a1){
T0* R=NULL;
T2 _idx=0;
T0* _node=NULL;
_idx=(r7hash_code(((T7*)a1)))%((/*RF2*/(C)->_capacity/*8*/));
_node=((/*RF2*/(C)->_buckets/*4*/))[_idx];
while (!(r7is_equal((T7*)((/*RF2*/(((T45*)_node))->_key/*8*/)),a1)))
{
_node=(/*RF2*/(((T45*)_node))->_next/*12*/);
}
R=(/*RF2*/(((T45*)_node))->_item/*4*/);
return R;
}

void r43put(T43* C,T0* a1,T0* a2){
T2 _h=0;
T2 _idx=0;
T0* _node=NULL;
(/*SFN*/C->_cache_user/*16*/)=-(1);
_h=r7hash_code(((T7*)a2));
_idx=(_h)%((/*RF2*/(C)->_capacity/*8*/));
_node=((/*RF2*/(C)->_buckets/*4*/))[_idx];
while (!(((_node)==((void*)(NULL)))||(r7is_equal((T7*)((/*RF2*/(((T45*)_node))->_key/*8*/)),a2))))
{
_node=(/*RF2*/(((T45*)_node))->_next/*12*/);
}
/*[IF*/
if((_node)==((void*)(NULL))){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))==((/*RF2*/(C)->_count/*12*/))){
r43increase_capacity(C);
_idx=(_h)%((/*RF2*/(C)->_capacity/*8*/));
}
/*FI]*/
{T45*n=new45();
r45make(n,a1,a2,((/*RF2*/(C)->_buckets/*4*/))[_idx]);
_node=((T0*)n);
}
((/*RF2*/(C)->_buckets/*4*/))[_idx]=(_node);
(/*SFN*/C->_count/*12*/)=((/*RF2*/(C)->_count/*12*/))+(1);
}
else{
/*[IRF3.3set_item*/((((T45*)(((T45*)_node))))->_item/*4*/)=(a1);
/*]*/
}
/*FI]*/
}

T0* r43item(T43* C,T2 a1){
T0* R=NULL;
r43set_cache_user(C,a1);
R=(/*RF2*/((T45*)((/*RF2*/(C)->_cache_node/*20*/)))->_item/*4*/);
return R;
}

void r43set_cache_user(T43* C,T2 a1){
/*[IF*/
if((a1)==(((/*RF2*/(C)->_cache_user/*16*/))+(1))){
(/*SFN*/C->_cache_user/*16*/)=a1;
(/*SFN*/C->_cache_node/*20*/)=(/*RF2*/((T45*)((/*RF2*/(C)->_cache_node/*20*/)))->_next/*12*/);
while (!(((/*RF2*/(C)->_cache_node/*20*/))!=((void*)(NULL))))
{
(/*SFN*/C->_cache_buckets/*24*/)=((/*RF2*/(C)->_cache_buckets/*24*/))+(1);
(/*SFN*/C->_cache_node/*20*/)=((/*RF2*/(C)->_buckets/*4*/))[(/*RF2*/(C)->_cache_buckets/*24*/)];
}
}
 else if((a1)==((/*RF2*/(C)->_cache_user/*16*/))){
}
 else if((a1)==(1)){
(/*SFN*/C->_cache_user/*16*/)=1;
(/*SFN*/C->_cache_buckets/*24*/)=0;
(/*SFN*/C->_cache_node/*20*/)=((/*RF2*/(C)->_buckets/*4*/))[(/*RF2*/(C)->_cache_buckets/*24*/)];
while (!(((/*RF2*/(C)->_cache_node/*20*/))!=((void*)(NULL))))
{
(/*SFN*/C->_cache_buckets/*24*/)=((/*RF2*/(C)->_cache_buckets/*24*/))+(1);
(/*SFN*/C->_cache_node/*20*/)=((/*RF2*/(C)->_buckets/*4*/))[(/*RF2*/(C)->_cache_buckets/*24*/)];
}
}
else{
r43set_cache_user(C,1);
while (!(((/*RF2*/(C)->_cache_user/*16*/))==(a1)))
{
r43set_cache_user(C,((/*RF2*/(C)->_cache_user/*16*/))+(1));
}
}
/*FI]*/
}

void r43increase_capacity(T43* C){
T2 _i=0;
T2 _idx=0;
T2 _new_capacity=0;
T46 _old_buckets=NULL;
T0* _node1=NULL;
T0* _node2=NULL;
int _hts=0;
_new_capacity=r47prime_number_ceiling(((/*RF2*/(C)->_capacity/*8*/))+(1));
_old_buckets=(/*RF2*/(C)->_buckets/*4*/);
(/*SFN*/C->_buckets/*4*/)=new46(_new_capacity);
_i=((/*RF2*/(C)->_capacity/*8*/))-(1);
(/*SFN*/C->_capacity/*8*/)=_new_capacity;
while (!((_i)<(0)))
{
_node1=(_old_buckets)[_i];
while (!((_node1)==((void*)(NULL))))
{
_node2=(/*RF2*/(((T45*)_node1))->_next/*12*/);
_idx=(r7hash_code((T7*)((/*RF2*/(((T45*)_node1))->_key/*8*/))))%((/*RF2*/(C)->_capacity/*8*/));
/*[IRF3.3set_next*/((((T45*)(((T45*)_node1))))->_next/*12*/)=(((/*RF2*/(C)->_buckets/*4*/))[_idx]);
/*]*/
((/*RF2*/(C)->_buckets/*4*/))[_idx]=(_node1);
_node1=_node2;
}
_i=(_i)-(1);
}
(/*SFN*/C->_cache_user/*16*/)=-(1);
}

T6 r43has(T43* C,T0* a1){
T6 R=0;
T2 _idx=0;
T0* _node=NULL;
_idx=(r7hash_code(((T7*)a1)))%((/*RF2*/(C)->_capacity/*8*/));
_node=((/*RF2*/(C)->_buckets/*4*/))[_idx];
while (!(((_node)==((void*)(NULL)))||(r7is_equal((T7*)((/*RF2*/(((T45*)_node))->_key/*8*/)),a1))))
{
_node=(/*RF2*/(((T45*)_node))->_next/*12*/);
}
R=(_node)!=((void*)(NULL));
return R;
}

void r43clear(T43* C){
r46set_all_with((/*RF2*/(C)->_buckets/*4*/),NULL,((/*RF2*/(C)->_capacity/*8*/))-(1));
(/*SFN*/C->_cache_user/*16*/)=-(1);
(/*SFN*/C->_count/*12*/)=0;
}

T0* r43twin(T43* C){
T0* R=NULL;
R=((void*)new43());
r43copy(((T43*)R),((T0*)C));
return R;
}

void r43with_capacity(T43* C,T2 a1){
T2 _new_capacity=0;
int _hts=0;
_new_capacity=r47prime_number_ceiling(a1);
(/*SFN*/C->_buckets/*4*/)=new46(_new_capacity);
(/*SFN*/C->_capacity/*8*/)=_new_capacity;
(/*SFN*/C->_cache_user/*16*/)=-(1);
(/*SFN*/C->_count/*12*/)=0;
}

void r59copy(T59* C,T0* a1){
r59from_collection(C,a1);
}

T0* r59item(T59* C,T2 a1){
T0* R=NULL;
/*[IF*/
if((a1)!=((/*RF2*/(C)->_mem_idx/*16*/))){
r59go_item(C,a1);
}
/*FI]*/
R=(/*RF2*/((T60*)((/*RF2*/(C)->_mem_lnk/*20*/)))->_item/*4*/);
return R;
}

void r59make(T59* C){
(/*SFN*/C->_first_link/*8*/)=NULL;
(/*SFN*/C->_upper/*4*/)=0;
(/*SFN*/C->_last_link/*12*/)=NULL;
(/*SFN*/C->_mem_idx/*16*/)=0;
(/*SFN*/C->_mem_lnk/*20*/)=NULL;
}

T0* r59_px_64(T59* C,T2 a1){
T0* R=NULL;
/*[IF*/
if((a1)!=((/*RF2*/(C)->_mem_idx/*16*/))){
r59go_item(C,a1);
}
/*FI]*/
R=(/*RF2*/((T60*)((/*RF2*/(C)->_mem_lnk/*20*/)))->_item/*4*/);
return R;
}

void r59add_last(T59* C,T0* a1){
T0* _lnk=NULL;
/*[IF*/
if(((/*RF2*/(C)->_first_link/*8*/))==((void*)(NULL))){
{T60*n=new60();
r60make(n,a1,NULL);
(/*SFN*/C->_first_link/*8*/)=((T0*)n);
}
(/*SFN*/C->_upper/*4*/)=1;
(/*SFN*/C->_last_link/*12*/)=(/*RF2*/(C)->_first_link/*8*/);
(/*SFN*/C->_mem_idx/*16*/)=1;
(/*SFN*/C->_mem_lnk/*20*/)=(/*RF2*/(C)->_first_link/*8*/);
}
else{
{T60*n=new60();
r60make(n,a1,NULL);
_lnk=((T0*)n);
}
/*[IRF3.3set_next*/((((T60*)((T60*)((/*RF2*/(C)->_last_link/*12*/)))))->_next/*8*/)=(_lnk);
/*]*/
(/*SFN*/C->_upper/*4*/)=((/*RF2*/(C)->_upper/*4*/))+(1);
(/*SFN*/C->_last_link/*12*/)=_lnk;
}
/*FI]*/
}

void r59clear(T59* C){
/*[IF*/
if(((/*RF2*/(C)->_first_link/*8*/))!=((void*)(NULL))){
(/*SFN*/C->_first_link/*8*/)=NULL;
(/*SFN*/C->_mem_idx/*16*/)=0;
(/*SFN*/C->_mem_lnk/*20*/)=NULL;
(/*SFN*/C->_upper/*4*/)=0;
(/*SFN*/C->_last_link/*12*/)=NULL;
}
/*FI]*/
}

T2 r59fast_index_of(T59* C,T0* a1){
T2 R=0;
T2 _u=0;
R=1;
_u=(/*RF2*/(C)->_upper/*4*/);
while (!(((R)>(_u))||((a1)==((void*)(r59item(C,R))))))
{
R=(R)+(1);
}
return R;
}

T0* r59twin(T59* C){
T0* R=NULL;
R=((void*)new59());
r59copy(((T59*)R),((T0*)C));
return R;
}

void r59go_item(T59* C,T2 a1){
/*[IF*/
if(((/*RF2*/(C)->_mem_idx/*16*/))>(a1)){
(/*SFN*/C->_mem_idx/*16*/)=1;
(/*SFN*/C->_mem_lnk/*20*/)=(/*RF2*/(C)->_first_link/*8*/);
}
/*FI]*/
while (!((a1)==((/*RF2*/(C)->_mem_idx/*16*/))))
{
(/*SFN*/C->_mem_lnk/*20*/)=(/*RF2*/((T60*)((/*RF2*/(C)->_mem_lnk/*20*/)))->_next/*8*/);
(/*SFN*/C->_mem_idx/*16*/)=((/*RF2*/(C)->_mem_idx/*16*/))+(1);
}
}

void r59from_collection(T59* C,T0* a1){
T2 _i=0;
T2 _up=0;
T0* _lnk=NULL;
/*[IF*/
if(((/*RF2*/(C)->_first_link/*8*/))==((void*)(NULL))){
_i=1;
_up=(/*RF2*/(((T59*)a1))->_upper/*4*/);
while (!((_i)>(_up)))
{
r59add_last(C,r59item(((T59*)a1),_i));
_i=(_i)+(1);
}
}
else{
_lnk=(/*RF2*/(C)->_first_link/*8*/);
_i=1;
_up=(/*RF2*/(((T59*)a1))->_upper/*4*/);
while (!((_i)>(_up)))
{
/*[IF*/
if((_lnk)==((void*)(NULL))){
r59add_last(C,r59item(((T59*)a1),_i));
}
else{
/*[IRF3.3set_item*/((((T60*)(((T60*)_lnk))))->_item/*4*/)=(r59item(((T59*)a1),_i));
/*]*/
_lnk=(/*RF2*/(((T60*)_lnk))->_next/*8*/);
}
/*FI]*/
_i=(_i)+(1);
}
/*[IF*/
if((_lnk)==((void*)((/*RF2*/(C)->_first_link/*8*/)))){
r59clear(C);
}
 else if((_lnk)!=((void*)(NULL))){
_i=/*(IRF4.3count*/(/*RF2*/(((T59*)a1))->_upper/*4*/)/*)*/;
/*[IF*/
if(((/*RF2*/(C)->_mem_idx/*16*/))!=(_i)){
r59go_item(C,_i);
}
/*FI]*/
/*[IRF3.3set_next*/((((T60*)((T60*)((/*RF2*/(C)->_mem_lnk/*20*/)))))->_next/*8*/)=(NULL);
/*]*/
(/*SFN*/C->_upper/*4*/)=_i;
(/*SFN*/C->_last_link/*12*/)=(/*RF2*/(C)->_mem_lnk/*20*/);
}
/*FI]*/
}
/*FI]*/
}

void r61copy(T61* C,T0* a1){
T2 _i=0;
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))==(0)){
r61with_capacity(C,((/*RF2*/(((T61*)a1))->_count/*12*/))+(1));
}
else{
r61clear(C);
}
/*FI]*/
_i=1;
while (!((_i)>((/*RF2*/(((T61*)a1))->_count/*12*/))))
{
r61put(C,r61item(((T61*)a1),_i),r61key(((T61*)a1),_i));
_i=(_i)+(1);
}
}

T0* r61key(T61* C,T2 a1){
T0* R=NULL;
r61set_cache_user(C,a1);
R=(/*RF2*/((T62*)((/*RF2*/(C)->_cache_node/*20*/)))->_key/*8*/);
return R;
}

T0* r61at(T61* C,T0* a1){
T0* R=NULL;
T2 _idx=0;
T0* _node=NULL;
_idx=(r7hash_code(((T7*)a1)))%((/*RF2*/(C)->_capacity/*8*/));
_node=((/*RF2*/(C)->_buckets/*4*/))[_idx];
while (!(r7is_equal((T7*)((/*RF2*/(((T62*)_node))->_key/*8*/)),a1)))
{
_node=(/*RF2*/(((T62*)_node))->_next/*12*/);
}
R=(/*RF2*/(((T62*)_node))->_item/*4*/);
return R;
}

void r61put(T61* C,T0* a1,T0* a2){
T2 _h=0;
T2 _idx=0;
T0* _node=NULL;
(/*SFN*/C->_cache_user/*16*/)=-(1);
_h=r7hash_code(((T7*)a2));
_idx=(_h)%((/*RF2*/(C)->_capacity/*8*/));
_node=((/*RF2*/(C)->_buckets/*4*/))[_idx];
while (!(((_node)==((void*)(NULL)))||(r7is_equal((T7*)((/*RF2*/(((T62*)_node))->_key/*8*/)),a2))))
{
_node=(/*RF2*/(((T62*)_node))->_next/*12*/);
}
/*[IF*/
if((_node)==((void*)(NULL))){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))==((/*RF2*/(C)->_count/*12*/))){
r61increase_capacity(C);
_idx=(_h)%((/*RF2*/(C)->_capacity/*8*/));
}
/*FI]*/
{T62*n=new62();
r62make(n,a1,a2,((/*RF2*/(C)->_buckets/*4*/))[_idx]);
_node=((T0*)n);
}
((/*RF2*/(C)->_buckets/*4*/))[_idx]=(_node);
(/*SFN*/C->_count/*12*/)=((/*RF2*/(C)->_count/*12*/))+(1);
}
else{
/*[IRF3.3set_item*/((((T62*)(((T62*)_node))))->_item/*4*/)=(a1);
/*]*/
}
/*FI]*/
}

T0* r61item(T61* C,T2 a1){
T0* R=NULL;
r61set_cache_user(C,a1);
R=(/*RF2*/((T62*)((/*RF2*/(C)->_cache_node/*20*/)))->_item/*4*/);
return R;
}

void r61set_cache_user(T61* C,T2 a1){
/*[IF*/
if((a1)==(((/*RF2*/(C)->_cache_user/*16*/))+(1))){
(/*SFN*/C->_cache_user/*16*/)=a1;
(/*SFN*/C->_cache_node/*20*/)=(/*RF2*/((T62*)((/*RF2*/(C)->_cache_node/*20*/)))->_next/*12*/);
while (!(((/*RF2*/(C)->_cache_node/*20*/))!=((void*)(NULL))))
{
(/*SFN*/C->_cache_buckets/*24*/)=((/*RF2*/(C)->_cache_buckets/*24*/))+(1);
(/*SFN*/C->_cache_node/*20*/)=((/*RF2*/(C)->_buckets/*4*/))[(/*RF2*/(C)->_cache_buckets/*24*/)];
}
}
 else if((a1)==((/*RF2*/(C)->_cache_user/*16*/))){
}
 else if((a1)==(1)){
(/*SFN*/C->_cache_user/*16*/)=1;
(/*SFN*/C->_cache_buckets/*24*/)=0;
(/*SFN*/C->_cache_node/*20*/)=((/*RF2*/(C)->_buckets/*4*/))[(/*RF2*/(C)->_cache_buckets/*24*/)];
while (!(((/*RF2*/(C)->_cache_node/*20*/))!=((void*)(NULL))))
{
(/*SFN*/C->_cache_buckets/*24*/)=((/*RF2*/(C)->_cache_buckets/*24*/))+(1);
(/*SFN*/C->_cache_node/*20*/)=((/*RF2*/(C)->_buckets/*4*/))[(/*RF2*/(C)->_cache_buckets/*24*/)];
}
}
else{
r61set_cache_user(C,1);
while (!(((/*RF2*/(C)->_cache_user/*16*/))==(a1)))
{
r61set_cache_user(C,((/*RF2*/(C)->_cache_user/*16*/))+(1));
}
}
/*FI]*/
}

void r61increase_capacity(T61* C){
T2 _i=0;
T2 _idx=0;
T2 _new_capacity=0;
T63 _old_buckets=NULL;
T0* _node1=NULL;
T0* _node2=NULL;
int _hts=0;
_new_capacity=r47prime_number_ceiling(((/*RF2*/(C)->_capacity/*8*/))+(1));
_old_buckets=(/*RF2*/(C)->_buckets/*4*/);
(/*SFN*/C->_buckets/*4*/)=new63(_new_capacity);
_i=((/*RF2*/(C)->_capacity/*8*/))-(1);
(/*SFN*/C->_capacity/*8*/)=_new_capacity;
while (!((_i)<(0)))
{
_node1=(_old_buckets)[_i];
while (!((_node1)==((void*)(NULL))))
{
_node2=(/*RF2*/(((T62*)_node1))->_next/*12*/);
_idx=(r7hash_code((T7*)((/*RF2*/(((T62*)_node1))->_key/*8*/))))%((/*RF2*/(C)->_capacity/*8*/));
/*[IRF3.3set_next*/((((T62*)(((T62*)_node1))))->_next/*12*/)=(((/*RF2*/(C)->_buckets/*4*/))[_idx]);
/*]*/
((/*RF2*/(C)->_buckets/*4*/))[_idx]=(_node1);
_node1=_node2;
}
_i=(_i)-(1);
}
(/*SFN*/C->_cache_user/*16*/)=-(1);
}

T6 r61has(T61* C,T0* a1){
T6 R=0;
T2 _idx=0;
T0* _node=NULL;
_idx=(r7hash_code(((T7*)a1)))%((/*RF2*/(C)->_capacity/*8*/));
_node=((/*RF2*/(C)->_buckets/*4*/))[_idx];
while (!(((_node)==((void*)(NULL)))||(r7is_equal((T7*)((/*RF2*/(((T62*)_node))->_key/*8*/)),a1))))
{
_node=(/*RF2*/(((T62*)_node))->_next/*12*/);
}
R=(_node)!=((void*)(NULL));
return R;
}

void r61clear(T61* C){
r63set_all_with((/*RF2*/(C)->_buckets/*4*/),NULL,((/*RF2*/(C)->_capacity/*8*/))-(1));
(/*SFN*/C->_cache_user/*16*/)=-(1);
(/*SFN*/C->_count/*12*/)=0;
}

T0* r61twin(T61* C){
T0* R=NULL;
R=((void*)new61());
r61copy(((T61*)R),((T0*)C));
return R;
}

void r61with_capacity(T61* C,T2 a1){
T2 _new_capacity=0;
int _hts=0;
_new_capacity=r47prime_number_ceiling(a1);
(/*SFN*/C->_buckets/*4*/)=new63(_new_capacity);
(/*SFN*/C->_capacity/*8*/)=_new_capacity;
(/*SFN*/C->_cache_user/*16*/)=-(1);
(/*SFN*/C->_count/*12*/)=0;
}

