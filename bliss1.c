#ifdef __cplusplus
extern "C" {
#endif
/*
ANSI C code generated by SmallEiffel The GNU Eiffel Compiler
Release -0.75 (July 16th 2001)
Copyright (C), 1994-2001 - LORIA - UHP - INRIA - FRANCE
Dominique COLNET and Suzanne COLLIN - SmallEiffel@loria.fr
http://SmallEiffel.loria.fr
*/
#ifdef __cplusplus
}
#endif
#include "bliss.h"
#ifdef __cplusplus
extern "C" {
#endif
/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT 
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of 
-- another product.
--          Copyright (C) 1994-98 LORIA - UHP - CRIN - INRIA - FRANCE
--            Dominique COLNET and Suzanne COLLIN - colnet@loria.fr 
--                       http://SmallEiffel.loria.fr
--
*/
/*
  This file (SmallEiffel/sys/runtime/base.c) is included for _all_ modes of 
  compilation (-boost, -no_check, ... -all_check, -debug_check).
*/

/*
  The wrapper for `malloc' (generated C code is supposed to use 
  only `se_malloc' instead of direct `malloc').
*/
void* se_malloc(size_t size) {
  void *result = malloc(size);
  if (result == NULL) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif SE_NO_CHECK
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory.\n");
  se_print_run_time_stack();
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}

/*
  The wrapper for `calloc' (generated C code is supposed to use 
  only `se_calloc' instead of direct `calloc').
*/
void* se_calloc(size_t nmemb, size_t size) {
  void *result = calloc(nmemb,size);
  if (result == NULL) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif SE_NO_CHECK
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory.\n");
  se_print_run_time_stack();
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}
T101 M101=0;
T84 M84={84};
T95 M95={95,0,0,0,0,0,0,0,0,0,0};
T207 M207={207,NULL,0};
T73 M73={73,NULL,NULL,NULL,NULL,NULL,0,0,0,0,NULL,0,0,0,0,0,NULL,NULL,0,NULL,NULL,0,0,0,0,0,0,NULL};
T173 M173={173,NULL,0,0};
T164 M164={164};
T178 M178={178,NULL,0,NULL};
T133 M133={133,NULL,0,0,0};
T160 M160={160};
T145 M145={145,NULL,0,0,0};
T137 M137={137,0,0,NULL};
T130 M130={130};
T113 M113={113,NULL,NULL};
T69 M69={69,NULL,NULL,NULL,NULL,NULL,0,0,0,0,NULL,0,0,0,NULL,0};
T201 M201={201,0,0,NULL,0};
T139 M139={139,NULL,0,0,0};
T27 M27={27,0};
T44 M44={44,NULL,0,0,0,NULL,0};
T59 M59={59,0,NULL,NULL,0,NULL};
T48 M48=0;
T61 M61={61,NULL,0,0,0,NULL,0};
T124 M124={124,NULL,NULL};
T162 M162={162,NULL,NULL,NULL};
T167 M167={167};
T98 M98={98,NULL,0,NULL};
T80 M80={80,0,NULL,NULL,0,NULL};
T136 M136={136,NULL,0,NULL,0,0,0,0,NULL,0,0,0,0};
T92 M92={92,0,0,0,0,NULL,NULL};
T169 M169={169,NULL,0,0,0};
T49 M49={49,0,NULL};
T174 M174={174,NULL,0,0,0};
T71 M71={71,NULL,NULL,NULL,NULL,NULL,0,0,0,0,NULL,0,0,0};
T202 M202={202,0,NULL,0};
T50 M50={50,0,0,NULL};
T81 M81={81,NULL,NULL};
T66 M66={66,NULL,NULL};
T148 M148={148,NULL,NULL,NULL,0,0};
T72 M72={72,NULL,NULL,NULL,NULL,NULL,0,0,0,0,NULL,0,0,0};
T121 M121={121,NULL,NULL};
T128 M128={128,0,0,0,NULL,NULL,0,NULL,0,NULL,0,NULL,0,NULL,0};
T165 M165={165};
T161 M161={161,NULL,0,0,0,NULL,0};
T123 M123={123,0,NULL,NULL,0,NULL};
T76 M76={76,NULL,0,0,0,NULL,0};
T64 M64={64,NULL,NULL,0,0};
T152 M152={152,NULL,0,0,0};
T186 M186={186,NULL,0,0,0};
T42 M42={42,NULL,NULL};
T110 M110={110,NULL,0};
T67 M67={67,NULL,NULL,NULL,NULL,NULL,0,0,0,0,NULL,0,0,0,NULL,0,0};
T200 M200={200,0,0,0,0,0};
T55 M55={55,NULL,0,0,0,NULL,0};
T108 M108={108,0,NULL};
T57 M57={57,NULL,0,NULL};
T65 M65={65,0,NULL,NULL,0,NULL};
T168 M168={168};
T199 M199={199,NULL,NULL};
T138 M138={138,0,0,NULL,NULL,NULL,0};
T7 M7={7,NULL,0,0};
T54 M54={54,NULL,0};
T56 M56={56,NULL,0,0,0,NULL,0};
T129 M129={129,NULL,NULL,0,NULL,0,0};
T82 M82={82,NULL,0};
T189 M189={189,NULL,0,0,0,NULL,0};
T157 M157={157,NULL,0,0,0};
T190 M190={190,NULL,NULL,NULL};
T198 M198={198,NULL,NULL};
T94 M94={94,0,0,0,0,0,0,NULL,0,0};
T46 M46={46,NULL,NULL,NULL};
T194 M194={194,0,0,0,0,NULL,0};
T77 M77={77,NULL,0,NULL};
T17 M17={17,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,0,NULL,NULL};
T192 M192={192,0,0,0,NULL,0,0,0,0,0,0};
T93 M93={93,0,0,0,0,0,0,0,0,0,0,NULL,NULL};
T75 M75={75,0,0,0,NULL,NULL};
T23 M23={23,0,0,NULL,0,0,0};
T142 M142={142,NULL,0,0,0};
T149 M149={149,NULL,0,0,0};
T33 M33={33,NULL,0,NULL,NULL,NULL,NULL,NULL,NULL,0,0,0,0,0,0,0,0,0,NULL};
T134 M134={134,0,NULL,NULL,0};
T182 M182={182,0,0,0,0,NULL,0};
T184 M184={184,NULL,0,0,0};
T51 M51={51,NULL,NULL,NULL};
T172 M172={172,0,0,NULL};
T60 M60={60,NULL,NULL};
T195 M195={195};
T135 M135={135,0,0,0,0};
T197 M197={197,0,0,NULL};
T91 M91={91,NULL,NULL};
T112 M112={112,NULL,NULL};
T40 M40={40,0,NULL,NULL,0,NULL};
T126 M126={126,NULL,NULL};
T106 M106={106,0,NULL,NULL,0,NULL};
T79 M79={79,NULL,NULL,NULL,0};
T62 M62={62,NULL,NULL,NULL};
T117 M117={117,NULL,0,0,0};
T166 M166={166};
T177 M177={177,NULL,0,0,0,NULL,0};
T74 M74={74,NULL,NULL,NULL,NULL,NULL,0,0,0,0,NULL,0,0,0,0,NULL};
/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT 
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of 
-- another product.
--          Copyright (C) 1994-98 LORIA - UHP - CRIN - INRIA - FRANCE
--            Dominique COLNET and Suzanne COLLIN - colnet@loria.fr 
--                       http://SmallEiffel.loria.fr
--
*/

/*
  This file (SmallEiffel/sys/runtime/boost.c) is automatically included when
  `run_control.boost' is true (ie. only for mode -boost).
*/

void se_print_run_time_stack (void) {
  fprintf(SE_ERR,"Eiffel program crash at run time.\n");
  fprintf(SE_ERR,"No trace when using option \"-boost\"\n");
}

void se_signal_handler(int sig) {
  printf("Received signal %d (man signal).\n",sig);
  se_print_run_time_stack();
  exit(EXIT_FAILURE);
}
unsigned int fsoc_count_ceil=424;
unsigned int rsoc_count_ceil=69;
/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT 
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of 
-- another product.
--          Copyright (C) 1994-98 LORIA - UHP - CRIN - INRIA - FRANCE
--            Dominique COLNET and Suzanne COLLIN - colnet@loria.fr 
--                       http://SmallEiffel.loria.fr
--
*/

/* 
   This file (SmallEiffel/sys/runtime/gc_lib.c) is automatically included 
   when the Garbage Collector is used (default, unless option -no_gc has been 
   selected).
*/

static void gcna_align_mark(rsoc*c,void*o);
static rsoc*rsocfl=NULL; /* ReSizable Object Chunk Free List. */

void**stack_bottom;
mch**gcmt=NULL; /* Garbage Collector Main Table. */
int gcmt_max=2048;
int gcmt_used=0;
fsoc*fsocfl=NULL; /* Fixed Size Object Chunk Free List. */
int gc_is_off=1;
unsigned int fsoc_count=0;
unsigned int rsoc_count=0;
void*gcmt_tail_addr=NULL;

static int chunk_rounded(int size) {
  int rounded_size = size;
  int diff = rounded_size%RSOC_SIZE;

  if (diff != 0) rounded_size += (RSOC_SIZE-diff);
  return rounded_size;
}

static void free_and_remove_from_gcmt(mch* c) {
  /* Remove and free the chunk `c' from the 
   * gcmt (Garbage Collector Main Table).
   */
  mch**p=(gcmt+gcmt_used-1);
  mch*save=*p;
  mch*save2;
  p--;
  while(save != c) {
    save2 = save;
    save = *p;
    *p = save2;
    p--;
  }
  free(c);
  gcmt_used--;
}

static void may_free_rsocfl(void) {
  /* May free all chunks of `rsocfl' (ReSizable Object Chunk Free List) 
     in some circumstances.
  */
  rsoc* next, *current;
  int count = rsocfl_count();
  if ((count > 50) && (count > (rsoc_count >> 1))) {
    current=rsocfl;
    rsocfl=NULL;
    while (current != NULL) {
      next=current->next;
      if (current->isize == current->header.size) {
	free_and_remove_from_gcmt(((mch*)current));
	rsoc_count--;
      }
      else {
	current->next=rsocfl;
	rsocfl=current;
      }
      current = next;
    }
  }
}

void gc_sweep(void) {
  mch** p2 = gcmt;
  mch** p1 = gcmt+1;
  mch**eogcmt=gcmt+gcmt_used;
  if (FREE_CHUNK((*p2)->state_type)) {
    if (RSO_FREE_CHUNK == ((*p2)->state_type)) {
      ((rsoc*)(*p2))->next=NULL;
      rsocfl=((rsoc*)(*p2));
    }
    else {
      rsocfl=NULL;
    }	
  }
  else {
    ((*gcmt)->swfp)(*p2);
    if (RSO_FREE_CHUNK==((*p2)->state_type)) {
      ((rsoc*)(*p2))->next=NULL;
      rsocfl=((rsoc*)(*p2));
    }
    else {
      rsocfl=NULL;
    }
  }
  while (p1 < eogcmt) {
    if (FREE_CHUNK((*p1)->state_type)) {
      if (RSO_FREE_CHUNK == ((*p1)->state_type)) {
	if (RSO_FREE_CHUNK == ((*p2)->state_type)) {
	  if (((char*)(*p2))+(*p2)->size == ((char*)(*p1))) {
	    ((*p2)->size)+=((*p1)->size);
	    p1++;
	  }
	  else {
	    ((rsoc*)(*p1))->next=rsocfl;
	    rsocfl=((rsoc*)(*p1));
	    *(p2+1)=*p1; p2++; p1++;
	  }
	}
	else {
	  ((rsoc*)(*p1))->next=rsocfl;
	  rsocfl=((rsoc*)(*p1));
	  *(p2+1)=*p1; p2++; p1++;
	}
      }
      else {
	*(p2+1)=*p1; p2++; p1++;
      }
    }
    else {
      ((*p1)->swfp)(*p1);
      if (RSO_FREE_CHUNK == ((*p1)->state_type)) {
	if (RSO_FREE_CHUNK == ((*p2)->state_type)) {
	  if (((char*)(*p2))+(*p2)->size == ((char*)(*p1))) {
	    ((*p2)->size)+=((*p1)->size);
	    p1++;
	  }
	  else {
	    ((rsoc*)(*p1))->next=rsocfl;
	    rsocfl=((rsoc*)(*p1));
	    *(p2+1)=*p1; p2++; p1++;
	  }
	}
	else {
	  ((rsoc*)(*p1))->next=rsocfl;
	  rsocfl=((rsoc*)(*p1));
	  *(p2+1)=*p1; p2++; p1++;
	}
      }
      else {
	*(p2+1)=*p1; p2++; p1++;
      }
    }
  }
  gcmt_used=(p2-gcmt)+1;
  may_free_rsocfl();
}

void gc_mark(void*p) {
  if ((p>((void*)*gcmt))&&(p<=gcmt_tail_addr)) {
    int i1=0;
    int i2=gcmt_used-1;
    int m=i2>>1;
    mch*c;
    for (;i2>i1;m=((i1+i2)>>1)) {
      if (p<=((void*)gcmt[m+1])) {
	i2=m;
      }
      else {
	i1=m+1;
      }
    }
    c=gcmt[i2];
    if (!(FREE_CHUNK(c->state_type))) {
      (c->amfp)(c,p);
    }
  }
}

int gc_stack_size(void) {
  void*stack_top[2]={NULL,NULL};
  if (stack_top > stack_bottom) {
    return ((void**)stack_top)-((void**)stack_bottom);
  }
  else {
    return ((void**)stack_bottom)-((void**)stack_top);
  }
}

/*
  To delay Garbage Collection when the stack is too large.
  To allow fast increase of ceils.
*/
#define FSOC_LIMIT (10240/((FSOC_SIZE)>>10))
#define RSOC_LIMIT (10240/((RSOC_SIZE)>>10)) 

/*
  When stack is too large, collection may be delayed.
*/
#define GCLARGESTACK 50000

int garbage_delayed(void) {
  /*
    To delay the first GC call.
  */
  if (gc_stack_size() > GCLARGESTACK) {
    if (fsoc_count_ceil <= fsoc_count) {
      if (rsoc_count_ceil <= rsoc_count) {
	if ((fsoc_count<FSOC_LIMIT)&&(rsoc_count<RSOC_LIMIT)) {
	  fsoc_count_ceil++;
	  rsoc_count_ceil++;
	  return 1;
	}
	else return 0;
      }
      else {
	if (fsoc_count<FSOC_LIMIT) {
	  fsoc_count_ceil++;
	  return 1;
	}
	else return 0;
      }
    }
    else {
      if (rsoc_count_ceil <= rsoc_count) {
	if (rsoc_count<RSOC_LIMIT) {
	  rsoc_count_ceil++;
	  return 1;
	}
	else return 0;
      }
      else return 0;
    }
  }
  else {
    return 0;
  }
}

void gc_update_ceils(void) {
  int c;

  /* Compute fsoc_count_ceil :
   */
  if (fsocfl==NULL) {
    if (fsoc_count >= fsoc_count_ceil) {
      if (fsoc_count_ceil<FSOC_LIMIT) {
	fsoc_count_ceil<<=1;
      }
      else { 
	c=fsoc_count+(fsoc_count/3);
	if (fsoc_count_ceil < c)
	  fsoc_count_ceil=c;
      }
    }
  }
  else
    if (fsoc_count_ceil < fsoc_count)
      fsoc_count_ceil=fsoc_count;
  /* Compute rsoc_count_ceil :
   */
  if (rsocfl==NULL) {
    if (rsoc_count>=rsoc_count_ceil) {
      if (rsoc_count_ceil<RSOC_LIMIT) {
	rsoc_count_ceil<<=1;
      }
      else { 
	c=rsoc_count+(rsoc_count/3);
	if (rsoc_count_ceil < c)
	  rsoc_count_ceil=c;
      }
    }
  }
  else
    if (rsoc_count_ceil < rsoc_count)
      rsoc_count_ceil=rsoc_count;
}

static void gc_add_into_gcmt(mch*c) {
  /* Update the `gcmt' (Garbage Collector Main Table) by adding the 
     new `mch' (Memory Chunk Header).
  */
  mch** p;
  if (gcmt_used == gcmt_max) {
    gcmt_max <<= 1;
    gcmt = ((mch**)(realloc(gcmt,(gcmt_max+1)*sizeof(void*))));
  }
  for (p=gcmt+(gcmt_used++ -1) ; (p>=gcmt)&&(*p>c) ; p--) {
    *(p+1) = *p;
  }
  *(p+1) = c;
}

static char*rso_from_store(na_env*nae,int size) {
  rsoh*r=(nae->store);
  nae->store_left-=size;
  if ((nae->store_left) > sizeof(rsoh)) {
    r->header.size=size;
    nae->store=((rsoh*)(((char*)(nae->store))+size));
  }
  else {
    r->header.size=size+nae->store_left;
    nae->store_left=0;
  }
  (r->header.magic_flag)=RSOH_UNMARKED;
  ((void)memset((r+1),0,r->header.size-sizeof(rsoh)));
  return (char*)(r+1);
}

static void rsoc_sweep(rsoc*c) {
  na_env*nae=c->nae;
  rsoh*gp=(rsoh*)&(c->first_header);
  rsoh*pp;
  rsoh*eoc=((rsoh*)(((char*)c)+c->header.size));
  c->free_list_of_large=NULL;
  if (c->header.size > RSOC_SIZE) {
    if (gp->header.magic_flag == RSOH_MARKED) {
      gp->header.magic_flag=RSOH_UNMARKED;
      c->next=nae->chunk_list;
      nae->chunk_list=c;
    }
    else {
      c->header.state_type=RSO_FREE_CHUNK;
    }
    return;
  }
  while (gp<eoc) {
    while (gp->header.magic_flag == RSOH_MARKED) {
      gp->header.magic_flag=RSOH_UNMARKED;
      gp=((rsoh*)(((char*)gp)+gp->header.size));
      if(gp>=eoc) {
	c->next=nae->chunk_list;
	nae->chunk_list=c;
	return;
      }
    }
    gp->header.magic_flag=RSOH_FREE;
    pp=(rsoh*)(((char*)gp)+gp->header.size);
    while ((pp<eoc)&&(pp->header.magic_flag != RSOH_MARKED)) {
      pp->header.magic_flag=RSOH_FREE;
      gp->header.size+=pp->header.size;
      pp=((rsoh*)(((char*)pp)+pp->header.size));
    }
    if (gp->header.size >= RSOC_MIN_STORE) {
      if (nae->store_left==0) {
	nae->store_left=gp->header.size;
	nae->store=gp;
	nae->store_chunk=c;
      }
      else if (nae->store->header.size < gp->header.size) {
	((fll_rsoh*)nae->store)->nextflol=nae->store_chunk->free_list_of_large;
	nae->store_chunk->free_list_of_large=((fll_rsoh*)nae->store);
	nae->store_left=gp->header.size;
	nae->store=gp;
	nae->store_chunk=c;
      }
      else {
	((fll_rsoh*)gp)->nextflol=c->free_list_of_large;
	c->free_list_of_large=((fll_rsoh*)gp);
      }
    }
    gp=pp;
  }
  if (((rsoh*)(&c->first_header))->header.size >= 
      (c->header.size-sizeof(rsoc)+sizeof(rsoh))){
    c->header.state_type=RSO_FREE_CHUNK;
    nae->store_chunk=NULL;
    nae->store_left=0; 
  }
  else{
    c->next=nae->chunk_list;
    nae->chunk_list=c;
  }
}

static const rsoc MRSOC = {
    {
	RSOC_SIZE,
	RSO_USED_CHUNK,
	((void(*)(mch*,void*))gcna_align_mark),
	((void(*)(mch*))rsoc_sweep)
    },
    0,
    NULL,
    NULL,
    NULL,
    {
      {
	0,
	RSOH_MARKED
      }
    }
};

static void rsoc_malloc(na_env*nae) {
  rsoc* r = ((rsoc*)(se_malloc(RSOC_SIZE)));
  rsoc_count++;
  *r=MRSOC;
  r->nae=nae;
  r->isize=RSOC_SIZE;
  nae->store=(&(r->first_header));
  nae->store_left=RSOC_SIZE-sizeof(rsoc)+sizeof(rsoh);
  nae->store_chunk=r;
  r->next=nae->chunk_list;
  nae->chunk_list=r;
  gc_add_into_gcmt((mch*)r);
}

static rsoc* rsocfl_best_fit(int size) {
  int best_size = 0;
  rsoc *pc,*best_pc,*best_c, *c;
  if (rsocfl==NULL)
    return NULL;
  pc=NULL;
  best_pc=NULL;
  best_c=NULL;
  c=rsocfl;
  while ((NULL!=c)&&(NULL==best_c)){
    if (c->header.size>=size){
      best_c=c;
      best_pc=pc;
      best_size=c->header.size;
    }
    pc=c;
    c=c->next;
  }
  if (NULL==c){
    if (best_pc != NULL)
      best_pc->next=best_c->next;
    else if (best_c==rsocfl)
      rsocfl=best_c->next;
    return best_c;
  }
  do {
    if ((c->header.size >= size) && (c->header.size < best_size)) {	
      best_c = c;
      best_pc = pc;
      best_size = c->header.size;
    }
    pc=c;
    c=c->next;
  } 
  while(c!=NULL);
  if (NULL==best_pc) {
    rsocfl = best_c->next;
  }
  else {
    best_pc->next=best_c->next;
  }
  return best_c;
}

static int get_store_in(rsoc*c,int size) {
  na_env*nae=c->nae;
  fll_rsoh*pf=NULL;
  fll_rsoh*f=c->free_list_of_large;
  while (f != NULL) {
    if (f->rsoh_field.size >= size) {
      nae->store_left=f->rsoh_field.size;
      nae->store=(rsoh*)f;
      nae->store_chunk=c;
      if (pf == NULL) {
	c->free_list_of_large=f->nextflol;
      }
      else {
	pf->nextflol=f->nextflol;
      }
      return 1;
    }
    pf = f;
    f = f->nextflol;
  }
  return 0;
}

char*new_na_from_chunk_list(na_env*nae,int size) {
  rsoc*c=nae->chunk_list;
  int csize;
  while (c != NULL) {
    if (get_store_in(c,size)) {
      return rso_from_store(nae,size);
    }	
    c = c->next;
  }
  csize=size+(sizeof(rsoc)-sizeof(rsoh));
  c=rsocfl_best_fit(csize);
  if (c != NULL){
    if ((c->header.size > RSOC_SIZE)
	&&
	(c->header.size-csize > RSOC_MIN_STORE*4)) {
      int csize_left=c->header.size-csize;
      if ((csize_left%sizeof(double))!=0) {
	csize_left-=(csize_left%sizeof(double));
	csize=c->header.size-csize_left;
      }
      c->header.size=csize_left;
      c->next=rsocfl;
      rsocfl=c;
      c=(rsoc*)(((char*)c)+csize_left);
      gc_add_into_gcmt((mch*)c);
      c->header.amfp=(void(*)(mch*,void*))gcna_align_mark;
      c->header.swfp=(void(*)(mch*))rsoc_sweep;
    }
    else {
      csize=c->header.size;
    }
    c->header.size=csize;
    c->header.state_type=RSO_USED_CHUNK;
    c->free_list_of_large=NULL;
    c->nae=nae;
    nae->store=(&(c->first_header));
    nae->store_left=csize-sizeof(rsoc)+sizeof(rsoh);
    nae->store_chunk=c;
    c->next=nae->chunk_list;
    nae->chunk_list=c;
    return rso_from_store(nae,size);
  }
  return NULL;
}

char*new_na(na_env*nae,int size) { 
  if (nae->store_left>0) {
    nae->store->header.size=nae->store_left;
    nae->store->header.magic_flag=RSOH_FREE;
    if (nae->store_left >= RSOC_MIN_STORE) {
      ((fll_rsoh*)(nae->store))->nextflol=nae->store_chunk->free_list_of_large;
      nae->store_chunk->free_list_of_large=((fll_rsoh*)nae->store);
    }
    nae->store_left=0;
  }
  if ((nae->store_chunk!=NULL)&&(get_store_in(nae->store_chunk,size))) {
    return rso_from_store(nae,size);
  }
  {
    char*r=new_na_from_chunk_list(nae,size);
    if (r!=NULL)
      return r;
  }
  if (rsoc_count<rsoc_count_ceil) {
    if((size+sizeof(rsoc)-sizeof(rsoh))>RSOC_SIZE){
      rsoc*c;
      rsoh*r;
      int rounded_size = chunk_rounded(size+sizeof(rsoc)-sizeof(rsoh));
      c=((rsoc*)(se_malloc(rounded_size)));
      r=(&(c->first_header));
      rsoc_count++;
      *c=MRSOC;
      c->isize = rounded_size;
      c->header.size=rounded_size;
      c->nae=nae;
      c->next=nae->chunk_list;
      nae->chunk_list=c;
      gc_add_into_gcmt((mch*)c);
      r->header.size=size;
      (r->header.magic_flag)=RSOH_UNMARKED;
      ((void)memset((r+1),0,size-sizeof(rsoh)));
      return (char*)(r+1);
    }
    else {
      rsoc_malloc(nae);
#ifdef GC_DEBUG
      printf("na from rsoc_malloc 1 (%i)\n",size);
#endif
      return rso_from_store(nae,size);
    }
  }
  gc_start();
  if (size<=(nae->store_left)) {
    return rso_from_store(nae,size);
  }
  {
    char*r=new_na_from_chunk_list(nae,size);
    if (r!=NULL) {
      return r;
    }
  }
  if((size+sizeof(rsoc)-sizeof(rsoh))>RSOC_SIZE){
    rsoc*c;
    rsoh*r;
    int rounded_size = chunk_rounded(size+sizeof(rsoc)-sizeof(rsoh));
    c=((rsoc*)(se_malloc(rounded_size)));
    r=(&(c->first_header));
    rsoc_count++;
    *c=MRSOC;
    c->isize = rounded_size;
    c->header.size=rounded_size;
    c->nae=nae;
    c->next=nae->chunk_list;
    nae->chunk_list=c;
    gc_add_into_gcmt((mch*)c);
    r->header.size=size;
    (r->header.magic_flag)=RSOH_UNMARKED;
    ((void)memset((r+1),0,size-sizeof(rsoh)));
    gc_update_ceils();
    return (char*)(r+1);
  }
  else {
    rsoc_malloc(nae);
    gc_update_ceils();
    return rso_from_store(nae,size);
  }
}

static void gcna_align_mark(rsoc*c,void*o) {
  na_env* nae = c->nae;
  fll_rsoh* f;
  fll_rsoh* pf;
  char* b = (char*)&(c->first_header);
  /* out of the chunck 'c' ? */
  if (((char*)o) > (((char*)c)+c->header.size)) {
      return;
  }
  /* properly aligned ? */
  if (((((char*)o)-((char*)c))%sizeof(int)) != 0) {
      return;
  }
  /* already marked ? */
  if ((((rsoh*)o)-1)->header.magic_flag != RSOH_UNMARKED) {
      return;
  }
  if (((char*)o) < ((char*)(c+1))) {
      return;
  }
  /* a large chunck ? */
  if (c->header.size > RSOC_SIZE) {
      if (o == (c+1)) {
	nae->gc_mark((T0*)o);
      }
      return;
  }
  pf=NULL;
  f=c->free_list_of_large;
  while ((f != NULL) && (f < ((fll_rsoh*)o))) {
      pf=f;
      f=f->nextflol;
  }
  if (pf == NULL) {
      pf=(fll_rsoh*)b;
  }
  while ((((rsoh*)pf)+1) < (rsoh*)o) {
      pf = ((fll_rsoh*)(((char*)pf)+pf->rsoh_field.size));
  }
  if (o == (((rsoh*)pf)+1)) {
    nae->gc_mark((T0*)o);
  } 
}

int rsocfl_count(void) {
  /* Returns the number of items in the ReSizable Object Free List.
  */
  int r=0;
  rsoc*p=rsocfl;
  while (p!=NULL) {
    r++;
    p=p->next;
  }
  return r;
}

int fsocfl_count(void) {
  int r=0;
  fsoc*p=fsocfl;
  while (p!=NULL) {
    r++;
    p=p->next;
  }
  return r;
}

void gc_dispose_before_exit(void) {
  mch** p = gcmt;
  mch**eogcmt=gcmt+gcmt_used;
    
  while (p < eogcmt) {
    if (((*p)->state_type == FSO_STORE_CHUNK) || 
	((*p)->state_type == FSO_USED_CHUNK)) {
      ((*p)->swfp)(*p);
    }
    p++;
  }
}

fsoc* gc_fsoc_get1(void) {
  /* Get a `fsoc' (Fixed Size Object Chunk) from the free fsoc list or
     allocate a new one (using `se_malloc') only when the ceil is not 
     yet reached. Otherwise, call the `gc_start()' function and 
     return NULL.
  */
  fsoc* result;
  if (fsocfl != NULL) {
    result = fsocfl;
    fsocfl = fsocfl->next;
    return result;
  }
  else if (fsoc_count_ceil > fsoc_count) {
    result = ((fsoc*)se_malloc(FSOC_SIZE));
    fsoc_count++;
    gc_add_into_gcmt((mch*)result);
    return result;
  }
  else {
    gc_start();
    return NULL;
  }
}

fsoc* gc_fsoc_get2(void) {
  /* Get a `fsoc' (Fixed Size Object Chunk) or force the allocation of a 
     new `fsoc' (using the `se_malloc' function). Update various ceils 
     accordingly.
  */
  fsoc* result;
  if (fsocfl != NULL) {
    result = fsocfl;
    fsocfl=fsocfl->next;
    return result;
  }
  else {
    result = ((fsoc*)(se_malloc(FSOC_SIZE)));
    gc_update_ceils();
    fsoc_count++;
    gc_add_into_gcmt((mch*)result);
    return result;
  }
}

unsigned int gc_start_count=0;
T0*oBC8string_buffer=NULL;


T2 r8hash_code(T8 C){
T2 R=0;
T9 _storage=NULL;
_storage=(/*RF2*/((T7*)(oBC8string_buffer))->_storage/*4*/);
{void*p=C;
sprintf(((char*)_storage),"%p",p);}
r7from_external((T7*)(oBC8string_buffer),((void*)(_storage)));
R=r7hash_code((T7*)(oBC8string_buffer));
return R;
}


T6 r6_ix_not(T6 C){
T6 R=0;
/*[IF*/
if(C){
}
else{
R=1;
}
/*FI]*/
return R;
}


T6 r3_px_6061(T3 C,T3 a1){
T6 R=0;
R=(T3code(C))<=(T3code(a1));
return R;
}


T6 r3is_digit(T3 C){
T6 R=0;
/*[IF*/
if((((unsigned)(C))>=((unsigned)(((T3)'0'))))){
R=(((unsigned)(C))<=((unsigned)(((T3)'9'))));
}
/*FI]*/
return R;
}


T6 r3is_hexadecimal_digit(T3 C){
T6 R=0;
/*[IF*/
if(r3is_digit(C)){
R=1;
}
 else if((((unsigned)(C))>=((unsigned)(((T3)'a'))))){
R=(((unsigned)(C))<=((unsigned)(((T3)'f'))));
}
 else if((((unsigned)(C))>=((unsigned)(((T3)'A'))))){
R=(((unsigned)(C))<=((unsigned)(((T3)'F'))));
}
/*FI]*/
return R;
}


T6 r3_px_6261(T3 C,T3 a1){
T6 R=0;
R=(T3code(C))>=(T3code(a1));
return R;
}


T2 r3value(T3 C){
T2 R=0;
R=(T3code(C))-(48);
return R;
}


T2 r3hexadecimal_value(T3 C){
T2 R=0;
/*[IF*/
if((T3code(C))<(T3code(((T3)'A')))){
R=(T3code(C))-(48);
}
 else if((T3code(C))<(T3code(((T3)'a')))){
R=(T3code(C))-(55);
}
else{
R=(T3code(C))-(87);
}
/*FI]*/
return R;
}


T6 r2is_equal(T2 C,T2 a1){
T6 R=0;
R=(!((C)<(a1)))&&(!((a1)<(C)));
return R;
}


T0* r2to_string(T2 C){
T0* R=NULL;
/*[IRF3.3clear*/((((T7*)((T7*)(oBC2tmp_string))))->_count/*8*/)=(0);
/*]*/
r2append_in(C,oBC2tmp_string);
R=r7twin((T7*)(oBC2tmp_string));
return R;
}
T0*oBC2tmp_string=NULL;


T3 r2digit(T2 C){
T3 R=0;
R=((T3)((C)+(T3code(((T3)'0')))));
return R;
}


T2 r2hash_code(T2 C){
T2 R=0;
/*[IF*/
if((C)<(0)){
R=-((C)+(1));
}
else{
R=C;
}
/*FI]*/
return R;
}


void r2append_in(T2 C,T0* a1){
T2 _i=0;
T2 _val=0;
/*[IF*/
if((C)==(0)){
r7extend(((T7*)a1),((T3)'0'));
}
else{
/*[IF*/
if((C)>(0)){
_i=((/*RF2*/(((T7*)a1))->_count/*8*/))+(1);
_val=C;
while (!((_val)==(0)))
{
r7extend(((T7*)a1),r2digit((_val)%(10)));
_val=(_val)/(10);
}
}
else{
r7extend(((T7*)a1),((T3)'\55'));
_i=((/*RF2*/(((T7*)a1))->_count/*8*/))+(1);
_val=C;
while (!((_val)==(0)))
{
r7extend(((T7*)a1),r2digit(-((_val)%(10))));
_val=(_val)/(10);
}
}
/*FI]*/
_val=(/*RF2*/(((T7*)a1))->_count/*8*/);
while (!((_i)>=(_val)))
{
r7swap(((T7*)a1),_i,_val);
_val=(_val)-(1);
_i=(_i)+(1);
}
}
/*FI]*/
}


T3 r2hexadecimal_digit(T2 C){
T3 R=0;
/*[IF*/
if((C)<=(9)){
R=r2digit(C);
}
else{
R=((T3)((T3code(((T3)'A')))+((C)-(10))));
}
/*FI]*/
return R;
}


T2 r5sign(T5 C){
T2 R=0;
/*[IF*/
if(((/*RF2*/C))<(T4toT5(0.0))){
R=-(1);
}
 else if(((/*RF2*/C))>(T4toT5(0.0))){
R=1;
}
/*FI]*/
return R;
}


T0* r5to_string(T5 C){
T0* R=NULL;
{T7*n=new7();
r7make(n,8);
R=((T0*)n);
}
/*[IRF3.6append_in*/{T5 C1=C;
T0* b1=R;
r5append_in_format(C1,b1,6);
}/*]*/
return R;
}


T5 r5double_ceiling(T5 C){
T5 R=0;
R=ceil(C);
return R;
}


T2 r5rounded(T5 C){
T2 R=0;
/*[IF*/
if(((floor(C))+(T4toT5(0.5)))<(C)){
R=((int)floor(r5double_ceiling(C)));
}
else{
R=((int)floor(floor(C)));
}
/*FI]*/
return R;
}
T9 oBC5sprintf_double_buffer=NULL;
int fBC5sprintf_double_buffer=0;


T9 r5sprintf_double_buffer(void){
if(fBC5sprintf_double_buffer==0){fBC5sprintf_double_buffer=1;{
oBC5sprintf_double_buffer=new9(1024);
}}
return oBC5sprintf_double_buffer;
}


void r5append_in_format(T5 C,T0* a1,T2 a2){
T2 _i=0;
{/*sprintf_double*/
char fmt[32];
double d=C;
fmt[0]='%';
fmt[1]='.';
sprintf(fmt+2,"%df\0",(a2));
sprintf(((char*)(r5sprintf_double_buffer())),fmt,d);
}
_i=0;
while (!(((r5sprintf_double_buffer())[_i])==(((T3)'\0'))))
{
r7extend(((T7*)a1),(r5sprintf_double_buffer())[_i]);
_i=(_i)+(1);
}
}


T5 r4pow(T4 C,T5 a1){
T5 R=0;
R=pow(((T5)(C)),a1);
return R;
}


T0* r4to_string(T4 C){
T0* R=NULL;
R=r5to_string(((T5)(C)));
return R;
}


T2 r4rounded(T4 C){
T2 R=0;
R=r5rounded(((T5)(C)));
return R;
}


T5 r4atan(T4 C){
T5 R=0;
R=atan(((T5)(C)));
return R;
}


void r159set_all_with(T159 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r159copy_from(T159 C,T159 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}


void r151set_all_with(T151 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r151copy_from(T151 C,T151 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}


void r163set_all_with(T163 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r141set_all_with(T141 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r141copy_from(T141 C,T141 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}


void r171set_all_with(T171 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r171copy_from(T171 C,T171 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}


void r118clear_all(T118 C,T2 a1){
T2 _i=0;
T5 _v=0;
_i=a1;
while (!((_i)<(0)))
{
(C)[_i]=(_v);
_i=(_i)-(1);
}
}


void r118set_all_with(T118 C,T5 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r118copy_from(T118 C,T118 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}


void r154set_all_with(T154 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r154copy_from(T154 C,T154 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}


void r58set_all_with(T58 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r99set_all_with(T99 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r144set_all_with(T144 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r144copy_from(T144 C,T144 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}


void r183clear_all(T183 C,T2 a1){
T2 _i=0;
T0* _v=NULL;
_i=a1;
while (!((_i)<(0)))
{
(C)[_i]=(_v);
_i=(_i)-(1);
}
}


void r183set_all_with(T183 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r183copy_from(T183 C,T183 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}


void r176set_all_with(T176 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r176copy_from(T176 C,T176 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}


void r78set_all_with(T78 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r179set_all_with(T179 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


T9 r9realloc(T9 C,T2 a1,T2 a2){
T9 R=NULL;
R=new9(a2);
r9copy_from(R,C,(a1)-(1));
return R;
}


void r9set_all_with(T9 C,T3 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


T6 r9fast_memcmp(T9 C,T9 a1,T2 a2){
T6 R=0;
T2 _i=0;
_i=(a2)-(1);
while (!(((_i)<(0))||(((C)[_i])!=((a1)[_i]))))
{
_i=(_i)-(1);
}
R=(_i)<(0);
return R;
}


void r9copy_at(T9 C,T2 a1,T9 a2,T2 a3){
T2 _i2=0;
T2 _i1=0;
_i1=a1;
while (!((_i2)==(a3)))
{
(C)[_i1]=((a2)[_i2]);
_i2=(_i2)+(1);
_i1=(_i1)+(1);
}
}


void r9copy_from(T9 C,T9 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}


void r63set_all_with(T63 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r191set_all_with(T191 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r47set_all_with(T47 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r156set_all_with(T156 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r156copy_from(T156 C,T156 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}


void r147set_all_with(T147 C,T2 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r147copy_from(T147 C,T147 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}


void r7copy(T7* C,T0* a1){
(/*SFN*/C->_count/*8*/)=(/*RF2*/(((T7*)a1))->_count/*8*/);
/*[IF*/
if(((/*RF2*/(C)->_count/*8*/))>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*12*/))<((/*RF2*/(C)->_count/*8*/))){
(/*SFN*/C->_storage/*4*/)=new9((/*RF2*/(C)->_count/*8*/));
(/*SFN*/C->_capacity/*12*/)=(/*RF2*/(C)->_count/*8*/);
}
/*FI]*/
r9copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T7*)a1))->_storage/*4*/),((/*RF2*/(C)->_count/*8*/))-(1));
}
/*FI]*/
}


T6 r7is_equal(T7* C,T0* a1){
T6 R=0;
/*[IF*/
if(((/*RF2*/(C)->_count/*8*/))==((/*RF2*/(((T7*)a1))->_count/*8*/))){
R=r9fast_memcmp((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T7*)a1))->_storage/*4*/),(/*RF2*/(C)->_count/*8*/));
}
/*FI]*/
return R;
}


void r7append(T7* C,T0* a1){
T2 _new_capacity=0;
T2 _needed_capacity=0;
T2 _s_count=0;
_s_count=(/*RF2*/(((T7*)a1))->_count/*8*/);
_needed_capacity=((/*RF2*/(C)->_count/*8*/))+(_s_count);
/*[IF*/
if((_needed_capacity)>((/*RF2*/(C)->_capacity/*12*/))){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*12*/))==(0)){
(/*SFN*/C->_storage/*4*/)=new9(_needed_capacity);
(/*SFN*/C->_capacity/*12*/)=_needed_capacity;
}
else{
_new_capacity=(2)*((/*RF2*/(C)->_capacity/*12*/));
/*[IF*/
if((_needed_capacity)>(_new_capacity)){
(/*SFN*/C->_storage/*4*/)=r9realloc((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(C)->_capacity/*12*/),_needed_capacity);
(/*SFN*/C->_capacity/*12*/)=_needed_capacity;
}
else{
(/*SFN*/C->_storage/*4*/)=r9realloc((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(C)->_capacity/*12*/),_new_capacity);
(/*SFN*/C->_capacity/*12*/)=_new_capacity;
}
/*FI]*/
}
/*FI]*/
}
/*FI]*/
r9copy_at((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(C)->_count/*8*/),(/*RF2*/(((T7*)a1))->_storage/*4*/),_s_count);
(/*SFN*/C->_count/*8*/)=_needed_capacity;
}


void r7make(T7* C,T2 a1){
/*[IF*/
if((a1)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*12*/))<(a1)){
(/*SFN*/C->_storage/*4*/)=new9(a1);
(/*SFN*/C->_capacity/*12*/)=a1;
}
/*FI]*/
}
/*FI]*/
(/*SFN*/C->_count/*8*/)=0;
}


void r7extend(T7* C,T3 a1){
T2 _new_capacity=0;
/*[IF*/
if(((/*RF2*/(C)->_capacity/*12*/))>((/*RF2*/(C)->_count/*8*/))){
}
 else if(((/*RF2*/(C)->_capacity/*12*/))==(0)){
(/*SFN*/C->_capacity/*12*/)=32;
(/*SFN*/C->_storage/*4*/)=new9((/*RF2*/(C)->_capacity/*12*/));
}
else{
_new_capacity=(2)*((/*RF2*/(C)->_capacity/*12*/));
(/*SFN*/C->_storage/*4*/)=r9realloc((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(C)->_capacity/*12*/),_new_capacity);
(/*SFN*/C->_capacity/*12*/)=_new_capacity;
}
/*FI]*/
((/*RF2*/(C)->_storage/*4*/))[(/*RF2*/(C)->_count/*8*/)]=(a1);
(/*SFN*/C->_count/*8*/)=((/*RF2*/(C)->_count/*8*/))+(1);
}


T0* r7_px_43(T7* C,T0* a1){
T0* R=NULL;
{T7*n=new7();
r7make(n,((/*RF2*/(C)->_count/*8*/))+((/*RF2*/(((T7*)a1))->_count/*8*/)));
R=((T0*)n);
}
r7append(((T7*)R),(T0*)C);
r7append(((T7*)R),a1);
return R;
}


T2 r7hash_code(T7* C){
T2 R=0;
T2 _j=0;
T2 _i=0;
_j=(/*RF2*/(C)->_count/*8*/);
_i=1;
while (!((_j)<=(0)))
{
R=((5)*(R))+(T3code(/*(IRF4.6item*/((/*RF2*/(C)->_storage/*4*/))[(_i)-(1)]/*)*/));
_i=(_i)+(1);
_j=(_j)-(1);
}
/*[IF*/
if((R)<(0)){
R=-((R)+(1));
}
/*FI]*/
return R;
}


void r7remove_last(T7* C,T2 a1){
(/*SFN*/C->_count/*8*/)=((/*RF2*/(C)->_count/*8*/))-(a1);
}


void r7append_character(T7* C,T3 a1){
T2 _new_capacity=0;
/*[IF*/
if(((/*RF2*/(C)->_capacity/*12*/))>((/*RF2*/(C)->_count/*8*/))){
}
 else if(((/*RF2*/(C)->_capacity/*12*/))==(0)){
(/*SFN*/C->_capacity/*12*/)=32;
(/*SFN*/C->_storage/*4*/)=new9((/*RF2*/(C)->_capacity/*12*/));
}
else{
_new_capacity=(2)*((/*RF2*/(C)->_capacity/*12*/));
(/*SFN*/C->_storage/*4*/)=r9realloc((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(C)->_capacity/*12*/),_new_capacity);
(/*SFN*/C->_capacity/*12*/)=_new_capacity;
}
/*FI]*/
((/*RF2*/(C)->_storage/*4*/))[(/*RF2*/(C)->_count/*8*/)]=(a1);
(/*SFN*/C->_count/*8*/)=((/*RF2*/(C)->_count/*8*/))+(1);
}


void r7add_last(T7* C,T3 a1){
T2 _new_capacity=0;
/*[IF*/
if(((/*RF2*/(C)->_capacity/*12*/))>((/*RF2*/(C)->_count/*8*/))){
}
 else if(((/*RF2*/(C)->_capacity/*12*/))==(0)){
(/*SFN*/C->_capacity/*12*/)=32;
(/*SFN*/C->_storage/*4*/)=new9((/*RF2*/(C)->_capacity/*12*/));
}
else{
_new_capacity=(2)*((/*RF2*/(C)->_capacity/*12*/));
(/*SFN*/C->_storage/*4*/)=r9realloc((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(C)->_capacity/*12*/),_new_capacity);
(/*SFN*/C->_capacity/*12*/)=_new_capacity;
}
/*FI]*/
((/*RF2*/(C)->_storage/*4*/))[(/*RF2*/(C)->_count/*8*/)]=(a1);
(/*SFN*/C->_count/*8*/)=((/*RF2*/(C)->_count/*8*/))+(1);
}


void r7from_external_copy(T7* C,T8 a1){
T2 _i=0;
T9 _s=NULL;
_s=a1;
(/*SFN*/C->_count/*8*/)=0;
while (!(((_s)[_i])==(((T3)'\0'))))
{
r7append_character(C,(_s)[_i]);
_i=(_i)+(1);
}
}


void r7from_external(T7* C,T8 a1){
(/*SFN*/C->_storage/*4*/)=a1;
(/*SFN*/C->_count/*8*/)=0;
while (!((((/*RF2*/(C)->_storage/*4*/))[(/*RF2*/(C)->_count/*8*/)])==(((T3)'\0'))))
{
(/*SFN*/C->_count/*8*/)=((/*RF2*/(C)->_count/*8*/))+(1);
}
(/*SFN*/C->_capacity/*12*/)=((/*RF2*/(C)->_count/*8*/))+(1);
}


T8 r7to_external(T7* C){
T8 R=NULL;
/*[IF*/
if(((/*RF2*/(C)->_capacity/*12*/))>((/*RF2*/(C)->_count/*8*/))){
(/*SFN*/C->_count/*8*/)=((/*RF2*/(C)->_count/*8*/))+(1);
/*[IF*/
if((/*(IRF4.6item*/((/*RF2*/(C)->_storage/*4*/))[((/*RF2*/(C)->_count/*8*/))-(1)]/*)*/)!=(((T3)'\0'))){
/*[IRF3.5put*/((/*RF2*/(C)->_storage/*4*/))[((/*RF2*/(C)->_count/*8*/))-(1)]=(((T3)'\0'));
/*]*/
}
/*FI]*/
}
else{
r7append_character(C,((T3)'\0'));
}
/*FI]*/
(/*SFN*/C->_count/*8*/)=((/*RF2*/(C)->_count/*8*/))-(1);
R=((void*)((/*RF2*/(C)->_storage/*4*/)));
return R;
}


T0* r7twin(T7* C){
T0* R=NULL;
R=((void*)new7());
r7copy(((T7*)R),((T0*)C));
return R;
}


void r7swap(T7* C,T2 a1,T2 a2){
T3 _tmp=0;
_tmp=/*(IRF4.6item*/((/*RF2*/(C)->_storage/*4*/))[(a1)-(1)]/*)*/;
/*[IRF3.5put*/((/*RF2*/(C)->_storage/*4*/))[(a1)-(1)]=(/*(IRF4.6item*/((/*RF2*/(C)->_storage/*4*/))[(a2)-(1)]/*)*/);
/*]*/
/*[IRF3.5put*/((/*RF2*/(C)->_storage/*4*/))[(a2)-(1)]=(_tmp);
/*]*/
}


void r133copy(T133* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T133*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T133*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
(/*SFN*/C->_storage/*4*/)=new156((/*RF2*/(C)->_capacity/*8*/));
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r156copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T133*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}


T2 r133count(T133* C){
T2 R=0;
R=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
return R;
}


T0* r133item(T133* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}


void r133make(T133* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new156(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
/*[IRF3.6clear_all*/{T133* C1=C;
T0* __value=NULL;
/*[IRF3.6set_all_with*/{T133* C2=C1;
T0* c1=__value;
r156set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,((/*RF2*/(C2)->_upper/*12*/))-((/*RF2*/(C2)->_lower/*16*/)));
}/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}


T0* r133twin(T133* C){
T0* R=NULL;
R=((void*)new133());
r133copy(((T133*)R),((T0*)C));
return R;
}


void r145copy(T145* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T145*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T145*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
(/*SFN*/C->_storage/*4*/)=new147((/*RF2*/(C)->_capacity/*8*/));
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r147copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T145*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}


T2 r145count(T145* C){
T2 R=0;
R=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
return R;
}


T2 r145item(T145* C,T2 a1){
T2 R=0;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}


void r145make(T145* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new147(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
/*[IRF3.6clear_all*/{T145* C1=C;
T2 __value=0;
/*[IRF3.6set_all_with*/{T145* C2=C1;
T2 c1=__value;
r147set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,((/*RF2*/(C2)->_upper/*12*/))-((/*RF2*/(C2)->_lower/*16*/)));
}/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}


T2 r145_px_64(T145* C,T2 a1){
T2 R=0;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}


T0* r145twin(T145* C){
T0* R=NULL;
R=((void*)new145());
r145copy(((T145*)R),((T0*)C));
return R;
}


void r145swap(T145* C,T2 a1,T2 a2){
T2 _tmp=0;
_tmp=r145item(C,a1);
/*[IRF3.6put*/{T145* C1=C;
T2 b1=r145item(C,a2);
T2 b2=a1;
((/*RF2*/(C1)->_storage/*4*/))[(b2)-((/*RF2*/(C1)->_lower/*16*/))]=(b1);
}/*]*/
/*[IRF3.6put*/{T145* C1=C;
T2 b1=_tmp;
T2 b2=a2;
((/*RF2*/(C1)->_storage/*4*/))[(b2)-((/*RF2*/(C1)->_lower/*16*/))]=(b1);
}/*]*/
}


void r139copy(T139* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T139*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T139*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
(/*SFN*/C->_storage/*4*/)=new141((/*RF2*/(C)->_capacity/*8*/));
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r141copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T139*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}


void r139make(T139* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new141(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
/*[IRF3.6clear_all*/{T139* C1=C;
T0* __value=NULL;
/*[IRF3.6set_all_with*/{T139* C2=C1;
T0* c1=__value;
r141set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,((/*RF2*/(C2)->_upper/*12*/))-((/*RF2*/(C2)->_lower/*16*/)));
}/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}


T0* r139_px_64(T139* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}


T0* r139twin(T139* C){
T0* R=NULL;
R=((void*)new139());
r139copy(((T139*)R),((T0*)C));
return R;
}


void r169copy(T169* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T169*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T169*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
(/*SFN*/C->_storage/*4*/)=new171((/*RF2*/(C)->_capacity/*8*/));
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r171copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T169*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}


T0* r169item(T169* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}


void r169make(T169* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new171(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
/*[IRF3.6clear_all*/{T169* C1=C;
T0* __value=NULL;
/*[IRF3.6set_all_with*/{T169* C2=C1;
T0* c1=__value;
r171set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,((/*RF2*/(C2)->_upper/*12*/))-((/*RF2*/(C2)->_lower/*16*/)));
}/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}


T0* r169_px_64(T169* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}


T0* r169twin(T169* C){
T0* R=NULL;
R=((void*)new169());
r169copy(((T169*)R),((T0*)C));
return R;
}


void r174copy(T174* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T174*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T174*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
(/*SFN*/C->_storage/*4*/)=new176((/*RF2*/(C)->_capacity/*8*/));
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r176copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T174*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}


void r174make(T174* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new176(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
/*[IRF3.6clear_all*/{T174* C1=C;
T0* __value=NULL;
/*[IRF3.6set_all_with*/{T174* C2=C1;
T0* c1=__value;
r176set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,((/*RF2*/(C2)->_upper/*12*/))-((/*RF2*/(C2)->_lower/*16*/)));
}/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}


T0* r174_px_64(T174* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}


T0* r174twin(T174* C){
T0* R=NULL;
R=((void*)new174());
r174copy(((T174*)R),((T0*)C));
return R;
}


void r152copy(T152* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T152*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T152*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
(/*SFN*/C->_storage/*4*/)=new154((/*RF2*/(C)->_capacity/*8*/));
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r154copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T152*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}


T0* r152item(T152* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}


void r152make(T152* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new154(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
/*[IRF3.6clear_all*/{T152* C1=C;
T0* __value=NULL;
/*[IRF3.6set_all_with*/{T152* C2=C1;
T0* c1=__value;
r154set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,((/*RF2*/(C2)->_upper/*12*/))-((/*RF2*/(C2)->_lower/*16*/)));
}/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}


T0* r152_px_64(T152* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}


T0* r152twin(T152* C){
T0* R=NULL;
R=((void*)new152());
r152copy(((T152*)R),((T0*)C));
return R;
}


void r186copy(T186* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T186*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T186*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
(/*SFN*/C->_storage/*4*/)=new9((/*RF2*/(C)->_capacity/*8*/));
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r9copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T186*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}


T3 r186item(T186* C,T2 a1){
T3 R=0;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}


void r186make(T186* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new9(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
/*[IRF3.6clear_all*/{T186* C1=C;
T3 __value=0;
/*[IRF3.6set_all_with*/{T186* C2=C1;
T3 c1=__value;
r9set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,((/*RF2*/(C2)->_upper/*12*/))-((/*RF2*/(C2)->_lower/*16*/)));
}/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}


T0* r186twin(T186* C){
T0* R=NULL;
R=((void*)new186());
r186copy(((T186*)R),((T0*)C));
return R;
}


void r157copy(T157* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T157*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T157*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
(/*SFN*/C->_storage/*4*/)=new159((/*RF2*/(C)->_capacity/*8*/));
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r159copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T157*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}


T0* r157item(T157* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}


void r157make(T157* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new159(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
/*[IRF3.6clear_all*/{T157* C1=C;
T0* __value=NULL;
/*[IRF3.6set_all_with*/{T157* C2=C1;
T0* c1=__value;
r159set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,((/*RF2*/(C2)->_upper/*12*/))-((/*RF2*/(C2)->_lower/*16*/)));
}/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}


T0* r157twin(T157* C){
T0* R=NULL;
R=((void*)new157());
r157copy(((T157*)R),((T0*)C));
return R;
}


void r142copy(T142* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T142*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T142*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
(/*SFN*/C->_storage/*4*/)=new144((/*RF2*/(C)->_capacity/*8*/));
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r144copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T142*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}


T0* r142item(T142* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}


void r142make(T142* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new144(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
/*[IRF3.6clear_all*/{T142* C1=C;
T0* __value=NULL;
/*[IRF3.6set_all_with*/{T142* C2=C1;
T0* c1=__value;
r144set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,((/*RF2*/(C2)->_upper/*12*/))-((/*RF2*/(C2)->_lower/*16*/)));
}/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}


T0* r142twin(T142* C){
T0* R=NULL;
R=((void*)new142());
r142copy(((T142*)R),((T0*)C));
return R;
}


void r149copy(T149* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T149*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T149*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
(/*SFN*/C->_storage/*4*/)=new151((/*RF2*/(C)->_capacity/*8*/));
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r151copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T149*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}


T0* r149item(T149* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}


void r149make(T149* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new151(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
/*[IRF3.6clear_all*/{T149* C1=C;
T0* __value=NULL;
/*[IRF3.6set_all_with*/{T149* C2=C1;
T0* c1=__value;
r151set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,((/*RF2*/(C2)->_upper/*12*/))-((/*RF2*/(C2)->_lower/*16*/)));
}/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}


T0* r149twin(T149* C){
T0* R=NULL;
R=((void*)new149());
r149copy(((T149*)R),((T0*)C));
return R;
}


void r184copy(T184* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T184*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T184*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
(/*SFN*/C->_storage/*4*/)=new183((/*RF2*/(C)->_capacity/*8*/));
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r183copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T184*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}


T2 r184count(T184* C){
T2 R=0;
R=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
return R;
}


T0* r184item(T184* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}


void r184make(T184* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new183(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
/*[IRF3.6clear_all*/{T184* C1=C;
T0* __value=NULL;
/*[IRF3.6set_all_with*/{T184* C2=C1;
T0* c1=__value;
r183set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,((/*RF2*/(C2)->_upper/*12*/))-((/*RF2*/(C2)->_lower/*16*/)));
}/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}


T0* r184_px_64(T184* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}


T0* r184twin(T184* C){
T0* R=NULL;
R=((void*)new184());
r184copy(((T184*)R),((T0*)C));
return R;
}


void r117copy(T117* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=/*SSWARF2*//*X117lower*/(/*RF2*/(((T117*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=/*SSWARF2*//*X117upper*/(/*RF2*/(((T117*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
(/*SFN*/C->_storage/*4*/)=new118((/*RF2*/(C)->_capacity/*8*/));
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r118copy_from((/*RF2*/(C)->_storage/*4*/),/*SSWARF2*//*X117storage*/((T118)((/*RF2*/(((T117*)a1))->_storage/*4*/))),(_needed_capacity)-(1));
}
/*FI]*/
}


void r117clear_all(T117* C){
T5 _value=0;
/*[IRF3.6set_all_with*/{T117* C1=C;
T5 b1=_value;
r118set_all_with((/*RF2*/(C1)->_storage/*4*/),b1,((/*RF2*/(C1)->_upper/*12*/))-((/*RF2*/(C1)->_lower/*16*/)));
}/*]*/
}


T5 r117item(T117* C,T2 a1){
T5 R=0;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}


void r117make(T117* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new118(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
r117clear_all(C);
}
/*FI]*/
}
/*FI]*/
}


T5 r117_px_64(T117* C,T2 a1){
T5 R=0;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}


T0* r117twin(T117* C){
T0* R=NULL;
R=((void*)new117());
r117copy(((T117*)R),((T0*)C));
return R;
}


void r207next(T207* C){
(/*SFN*/C->_item_index/*8*/)=((/*RF2*/(C)->_item_index/*8*/))+(1);
}


T0* r207item(T207* C){
T0* R=NULL;
R=r189item((T189*)((/*RF2*/(C)->_dictionary/*4*/)),(/*RF2*/(C)->_item_index/*8*/));
return R;
}


void r207make(T207* C,T0* a1){
(/*SFN*/C->_dictionary/*4*/)=a1;
(/*SFN*/C->_item_index/*8*/)=1;
}


T6 r207is_off(T207* C){
T6 R=0;
R=((/*RF2*/(C)->_item_index/*8*/))>((/*RF2*/((T189*)((/*RF2*/(C)->_dictionary/*4*/)))->_count/*12*/));
return R;
}


T0* r207twin(T207* C){
T0* R=NULL;
R=((void*)new207());
*((T207*)R)=*C;
return R;
}


void r178make(T178* C,T0* a1,T2 a2,T0* a3){
(/*SFN*/C->_item/*4*/)=a1;
(/*SFN*/C->_key/*8*/)=a2;
(/*SFN*/C->_next/*12*/)=a3;
}


T0* r178twin(T178* C){
T0* R=NULL;
R=((void*)new178());
*((T178*)R)=*C;
return R;
}


void r113next(T113* C){
(/*SFN*/C->_current_link/*8*/)=(/*RF2*/((T81*)((/*RF2*/(C)->_current_link/*8*/)))->_next/*8*/);
}


void r113make(T113* C,T0* a1){
(/*SFN*/C->_linked_list/*4*/)=a1;
(/*SFN*/C->_current_link/*8*/)=(/*RF2*/((T80*)((/*RF2*/(C)->_linked_list/*4*/)))->_first_link/*8*/);
}


void r113start(T113* C){
(/*SFN*/C->_current_link/*8*/)=(/*RF2*/((T80*)((/*RF2*/(C)->_linked_list/*4*/)))->_first_link/*8*/);
}


T0* r113twin(T113* C){
T0* R=NULL;
R=((void*)new113());
*((T113*)R)=*C;
return R;
}


void r44copy(T44* C,T0* a1){
T2 _i=0;
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))==(0)){
r44with_capacity(C,((/*RF2*/(((T44*)a1))->_count/*12*/))+(1));
}
else{
r44clear(C);
}
/*FI]*/
_i=1;
while (!((_i)>((/*RF2*/(((T44*)a1))->_count/*12*/))))
{
r44put(C,r44item(((T44*)a1),_i),r44key(((T44*)a1),_i));
_i=(_i)+(1);
}
}


T0* r44key(T44* C,T2 a1){
T0* R=NULL;
r44set_cache_user(C,a1);
R=(/*RF2*/((T46*)((/*RF2*/(C)->_cache_node/*20*/)))->_key/*8*/);
return R;
}


T0* r44at(T44* C,T0* a1){
T0* R=NULL;
T0* _node=NULL;
T2 _idx=0;
_idx=(r7hash_code(((T7*)a1)))%((/*RF2*/(C)->_capacity/*8*/));
_node=((/*RF2*/(C)->_buckets/*4*/))[_idx];
while (!(r7is_equal((T7*)((/*RF2*/(((T46*)_node))->_key/*8*/)),a1)))
{
_node=(/*RF2*/(((T46*)_node))->_next/*12*/);
}
R=(/*RF2*/(((T46*)_node))->_item/*4*/);
return R;
}


void r44put(T44* C,T0* a1,T0* a2){
T0* _node=NULL;
T2 _idx=0;
T2 _h=0;
(/*SFN*/C->_cache_user/*16*/)=-(1);
_h=r7hash_code(((T7*)a2));
_idx=(_h)%((/*RF2*/(C)->_capacity/*8*/));
_node=((/*RF2*/(C)->_buckets/*4*/))[_idx];
while (!(((_node)==((void*)(NULL)))||(r7is_equal((T7*)((/*RF2*/(((T46*)_node))->_key/*8*/)),a2))))
{
_node=(/*RF2*/(((T46*)_node))->_next/*12*/);
}
/*[IF*/
if((_node)==((void*)(NULL))){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))==((/*RF2*/(C)->_count/*12*/))){
r44increase_capacity(C);
_idx=(_h)%((/*RF2*/(C)->_capacity/*8*/));
}
/*FI]*/
{T46*n=new46();
r46make(n,a1,a2,((/*RF2*/(C)->_buckets/*4*/))[_idx]);
_node=((T0*)n);
}
((/*RF2*/(C)->_buckets/*4*/))[_idx]=(_node);
(/*SFN*/C->_count/*12*/)=((/*RF2*/(C)->_count/*12*/))+(1);
}
else{
/*[IRF3.3set_item*/((((T46*)(((T46*)_node))))->_item/*4*/)=(a1);
/*]*/
}
/*FI]*/
}


T0* r44item(T44* C,T2 a1){
T0* R=NULL;
r44set_cache_user(C,a1);
R=(/*RF2*/((T46*)((/*RF2*/(C)->_cache_node/*20*/)))->_item/*4*/);
return R;
}


void r44set_cache_user(T44* C,T2 a1){
/*[IF*/
if((a1)==(((/*RF2*/(C)->_cache_user/*16*/))+(1))){
(/*SFN*/C->_cache_user/*16*/)=a1;
(/*SFN*/C->_cache_node/*20*/)=(/*RF2*/((T46*)((/*RF2*/(C)->_cache_node/*20*/)))->_next/*12*/);
while (!(((/*RF2*/(C)->_cache_node/*20*/))!=((void*)(NULL))))
{
(/*SFN*/C->_cache_buckets/*24*/)=((/*RF2*/(C)->_cache_buckets/*24*/))+(1);
(/*SFN*/C->_cache_node/*20*/)=((/*RF2*/(C)->_buckets/*4*/))[(/*RF2*/(C)->_cache_buckets/*24*/)];
}
}
 else if((a1)==((/*RF2*/(C)->_cache_user/*16*/))){
}
 else if((a1)==(1)){
(/*SFN*/C->_cache_user/*16*/)=1;
(/*SFN*/C->_cache_buckets/*24*/)=0;
(/*SFN*/C->_cache_node/*20*/)=((/*RF2*/(C)->_buckets/*4*/))[(/*RF2*/(C)->_cache_buckets/*24*/)];
while (!(((/*RF2*/(C)->_cache_node/*20*/))!=((void*)(NULL))))
{
(/*SFN*/C->_cache_buckets/*24*/)=((/*RF2*/(C)->_cache_buckets/*24*/))+(1);
(/*SFN*/C->_cache_node/*20*/)=((/*RF2*/(C)->_buckets/*4*/))[(/*RF2*/(C)->_cache_buckets/*24*/)];
}
}
else{
r44set_cache_user(C,1);
while (!(((/*RF2*/(C)->_cache_user/*16*/))==(a1)))
{
r44set_cache_user(C,((/*RF2*/(C)->_cache_user/*16*/))+(1));
}
}
/*FI]*/
}


void r44increase_capacity(T44* C){
int _hts=0;
T0* _node2=NULL;
T0* _node1=NULL;
T47 _old_buckets=NULL;
T2 _new_capacity=0;
T2 _idx=0;
T2 _i=0;
_new_capacity=r48prime_number_ceiling(((/*RF2*/(C)->_capacity/*8*/))+(1));
_old_buckets=(/*RF2*/(C)->_buckets/*4*/);
(/*SFN*/C->_buckets/*4*/)=new47(_new_capacity);
_i=((/*RF2*/(C)->_capacity/*8*/))-(1);
(/*SFN*/C->_capacity/*8*/)=_new_capacity;
while (!((_i)<(0)))
{
_node1=(_old_buckets)[_i];
while (!((_node1)==((void*)(NULL))))
{
_node2=(/*RF2*/(((T46*)_node1))->_next/*12*/);
_idx=(r7hash_code((T7*)((/*RF2*/(((T46*)_node1))->_key/*8*/))))%((/*RF2*/(C)->_capacity/*8*/));
/*[IRF3.3set_next*/((((T46*)(((T46*)_node1))))->_next/*12*/)=(((/*RF2*/(C)->_buckets/*4*/))[_idx]);
/*]*/
((/*RF2*/(C)->_buckets/*4*/))[_idx]=(_node1);
_node1=_node2;
}
_i=(_i)-(1);
}
(/*SFN*/C->_cache_user/*16*/)=-(1);
}


T6 r44has(T44* C,T0* a1){
T6 R=0;
T0* _node=NULL;
T2 _idx=0;
_idx=(r7hash_code(((T7*)a1)))%((/*RF2*/(C)->_capacity/*8*/));
_node=((/*RF2*/(C)->_buckets/*4*/))[_idx];
while (!(((_node)==((void*)(NULL)))||(r7is_equal((T7*)((/*RF2*/(((T46*)_node))->_key/*8*/)),a1))))
{
_node=(/*RF2*/(((T46*)_node))->_next/*12*/);
}
R=(_node)!=((void*)(NULL));
return R;
}


void r44clear(T44* C){
r47set_all_with((/*RF2*/(C)->_buckets/*4*/),NULL,((/*RF2*/(C)->_capacity/*8*/))-(1));
(/*SFN*/C->_cache_user/*16*/)=-(1);
(/*SFN*/C->_count/*12*/)=0;
}


T0* r44twin(T44* C){
T0* R=NULL;
R=((void*)new44());
r44copy(((T44*)R),((T0*)C));
return R;
}


void r44with_capacity(T44* C,T2 a1){
int _hts=0;
T2 _new_capacity=0;
_new_capacity=r48prime_number_ceiling(a1);
(/*SFN*/C->_buckets/*4*/)=new47(_new_capacity);
(/*SFN*/C->_capacity/*8*/)=_new_capacity;
(/*SFN*/C->_cache_user/*16*/)=-(1);
(/*SFN*/C->_count/*12*/)=0;
}


void r59copy(T59* C,T0* a1){
r59from_collection(C,a1);
}


T0* r59item(T59* C,T2 a1){
T0* R=NULL;
/*[IF*/
if((a1)!=((/*RF2*/(C)->_mem_idx/*16*/))){
r59go_item(C,a1);
}
/*FI]*/
R=(/*RF2*/((T60*)((/*RF2*/(C)->_mem_lnk/*20*/)))->_item/*4*/);
return R;
}


void r59make(T59* C){
(/*SFN*/C->_first_link/*8*/)=NULL;
(/*SFN*/C->_upper/*4*/)=0;
(/*SFN*/C->_last_link/*12*/)=NULL;
(/*SFN*/C->_mem_idx/*16*/)=0;
(/*SFN*/C->_mem_lnk/*20*/)=NULL;
}


T0* r59_px_64(T59* C,T2 a1){
T0* R=NULL;
/*[IF*/
if((a1)!=((/*RF2*/(C)->_mem_idx/*16*/))){
r59go_item(C,a1);
}
/*FI]*/
R=(/*RF2*/((T60*)((/*RF2*/(C)->_mem_lnk/*20*/)))->_item/*4*/);
return R;
}


void r59add_last(T59* C,T0* a1){
T0* _lnk=NULL;
/*[IF*/
if(((/*RF2*/(C)->_first_link/*8*/))==((void*)(NULL))){
{T60*n=new60();
r60make(n,a1,NULL);
(/*SFN*/C->_first_link/*8*/)=((T0*)n);
}
(/*SFN*/C->_upper/*4*/)=1;
(/*SFN*/C->_last_link/*12*/)=(/*RF2*/(C)->_first_link/*8*/);
(/*SFN*/C->_mem_idx/*16*/)=1;
(/*SFN*/C->_mem_lnk/*20*/)=(/*RF2*/(C)->_first_link/*8*/);
}
else{
{T60*n=new60();
r60make(n,a1,NULL);
_lnk=((T0*)n);
}
/*[IRF3.3set_next*/((((T60*)((T60*)((/*RF2*/(C)->_last_link/*12*/)))))->_next/*8*/)=(_lnk);
/*]*/
(/*SFN*/C->_upper/*4*/)=((/*RF2*/(C)->_upper/*4*/))+(1);
(/*SFN*/C->_last_link/*12*/)=_lnk;
}
/*FI]*/
}


void r59clear(T59* C){
/*[IF*/
if(((/*RF2*/(C)->_first_link/*8*/))!=((void*)(NULL))){
(/*SFN*/C->_first_link/*8*/)=NULL;
(/*SFN*/C->_mem_idx/*16*/)=0;
(/*SFN*/C->_mem_lnk/*20*/)=NULL;
(/*SFN*/C->_upper/*4*/)=0;
(/*SFN*/C->_last_link/*12*/)=NULL;
}
/*FI]*/
}


T2 r59fast_index_of(T59* C,T0* a1){
T2 R=0;
T2 _u=0;
R=1;
_u=(/*RF2*/(C)->_upper/*4*/);
while (!(((R)>(_u))||((a1)==((void*)(r59item(C,R))))))
{
R=(R)+(1);
}
return R;
}


T0* r59twin(T59* C){
T0* R=NULL;
R=((void*)new59());
r59copy(((T59*)R),((T0*)C));
return R;
}


void r59go_item(T59* C,T2 a1){
/*[IF*/
if(((/*RF2*/(C)->_mem_idx/*16*/))>(a1)){
(/*SFN*/C->_mem_idx/*16*/)=1;
(/*SFN*/C->_mem_lnk/*20*/)=(/*RF2*/(C)->_first_link/*8*/);
}
/*FI]*/
while (!((a1)==((/*RF2*/(C)->_mem_idx/*16*/))))
{
(/*SFN*/C->_mem_lnk/*20*/)=(/*RF2*/((T60*)((/*RF2*/(C)->_mem_lnk/*20*/)))->_next/*8*/);
(/*SFN*/C->_mem_idx/*16*/)=((/*RF2*/(C)->_mem_idx/*16*/))+(1);
}
}


void r59from_collection(T59* C,T0* a1){
T0* _lnk=NULL;
T2 _up=0;
T2 _i=0;
/*[IF*/
if(((/*RF2*/(C)->_first_link/*8*/))==((void*)(NULL))){
_i=1;
_up=(/*RF2*/(((T59*)a1))->_upper/*4*/);
while (!((_i)>(_up)))
{
r59add_last(C,r59item(((T59*)a1),_i));
_i=(_i)+(1);
}
}
else{
_lnk=(/*RF2*/(C)->_first_link/*8*/);
_i=1;
_up=(/*RF2*/(((T59*)a1))->_upper/*4*/);
while (!((_i)>(_up)))
{
/*[IF*/
if((_lnk)==((void*)(NULL))){
r59add_last(C,r59item(((T59*)a1),_i));
}
else{
/*[IRF3.3set_item*/((((T60*)(((T60*)_lnk))))->_item/*4*/)=(r59item(((T59*)a1),_i));
/*]*/
_lnk=(/*RF2*/(((T60*)_lnk))->_next/*8*/);
}
/*FI]*/
_i=(_i)+(1);
}
/*[IF*/
if((_lnk)==((void*)((/*RF2*/(C)->_first_link/*8*/)))){
r59clear(C);
}
 else if((_lnk)!=((void*)(NULL))){
_i=/*(IRF4.3count*/(/*RF2*/(((T59*)a1))->_upper/*4*/)/*)*/;
/*[IF*/
if(((/*RF2*/(C)->_mem_idx/*16*/))!=(_i)){
r59go_item(C,_i);
}
/*FI]*/
/*[IRF3.3set_next*/((((T60*)((T60*)((/*RF2*/(C)->_mem_lnk/*20*/)))))->_next/*8*/)=(NULL);
/*]*/
(/*SFN*/C->_upper/*4*/)=_i;
(/*SFN*/C->_last_link/*12*/)=(/*RF2*/(C)->_mem_lnk/*20*/);
}
/*FI]*/
}
/*FI]*/
}

