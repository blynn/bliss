#ifdef __cplusplus
extern "C" {
#endif
/*
ANSI C code generated by SmallEiffel The GNU Eiffel Compiler
Release -0.75 (July 16th 2001)
Copyright (C), 1994-2001 - LORIA - UHP - INRIA - FRANCE
Dominique COLNET and Suzanne COLLIN - SmallEiffel@loria.fr
http://SmallEiffel.loria.fr
*/
#ifdef __cplusplus
}
#endif
#include "main.h"
#ifdef __cplusplus
extern "C" {
#endif
/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT 
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of 
-- another product.
--          Copyright (C) 1994-98 LORIA - UHP - CRIN - INRIA - FRANCE
--            Dominique COLNET and Suzanne COLLIN - colnet@loria.fr 
--                       http://SmallEiffel.loria.fr
--
*/
/*
  This file (SmallEiffel/sys/runtime/base.c) is included for _all_ modes of 
  compilation (-boost, -no_check, ... -all_check, -debug_check).
*/

/*
  The wrapper for `malloc' (generated C code is supposed to use 
  only `se_malloc' instead of direct `malloc').
*/
void* se_malloc(size_t size) {
  void *result = malloc(size);
  if (result == NULL) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif SE_NO_CHECK
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory.\n");
  se_print_run_time_stack();
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}

/*
  The wrapper for `calloc' (generated C code is supposed to use 
  only `se_calloc' instead of direct `calloc').
*/
void* se_calloc(size_t nmemb, size_t size) {
  void *result = calloc(nmemb,size);
  if (result == NULL) {
#ifdef SE_EXCEPTIONS
    internal_exception_handler(No_more_memory);
#elif SE_NO_CHECK
    error0("No more memory.", NULL);
#else
  fprintf(SE_ERR,"No more memory.\n");
  se_print_run_time_stack();
  exit(EXIT_FAILURE);
#endif
  }
  return result;
}
T101 M101=0;
T84 M84={84,0,0};
T95 M95={95,0,0,0,0,0,0,0,0,0,0};
T196 M196={196,NULL,0};
T73 M73={73,NULL,NULL,NULL,NULL,NULL,0,0,0,0,NULL,0,0,0,0,0,0,NULL};
T171 M171={171,NULL,0,0};
T162 M162={162};
T176 M176={176,NULL,0,NULL};
T131 M131={131,NULL,0,0,0};
T158 M158={158};
T143 M143={143,NULL,0,0,0};
T135 M135={135,0,0,NULL};
T128 M128={128};
T113 M113={113,NULL,NULL};
T68 M68={68,NULL,NULL,NULL,NULL,NULL,0,0,0,0,NULL,NULL,0};
T17 M17={17,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,0,NULL,NULL};
T206 M206={206,0,0,NULL,0};
T137 M137={137,NULL,0,0,0};
T27 M27={27,0};
T45 M45={45,NULL,0,0,0,NULL,0};
T60 M60={60,0,NULL,NULL,0,NULL};
T49 M49=0;
T62 M62={62,NULL,0,0,0,NULL,0};
T121 M121={121,NULL,NULL};
T160 M160={160,NULL,NULL,NULL};
T165 M165={165};
T98 M98={98,NULL,0,NULL};
T80 M80={80,0,NULL,NULL,0,NULL};
T134 M134={134,NULL,0,NULL,0,0,0,0,NULL,0,0,0,0};
T92 M92={92,0,0,0,0,NULL,NULL};
T167 M167={167,NULL,0,0,0};
T50 M50={50,0,NULL};
T172 M172={172,NULL,0,0,0};
T70 M70={70,NULL,NULL,NULL,NULL,NULL,0,0,0,0,NULL};
T207 M207={207,0,NULL,0};
T51 M51={51,0,0,NULL};
T81 M81={81,NULL,NULL};
T67 M67={67,NULL,NULL};
T146 M146={146,NULL,NULL,NULL,0,0};
T72 M72={72,NULL,NULL,NULL,NULL,NULL,0,0,0,0,NULL};
T187 M187={187,NULL,NULL};
T126 M126={126,0,0,0,NULL,NULL,0,NULL,0,NULL,0,NULL,0,NULL,0};
T163 M163={163};
T159 M159={159,NULL,0,0,0,NULL,0};
T120 M120={120,0,NULL,NULL,0,NULL};
T76 M76={76,NULL,0,0,0,NULL,0};
T65 M65={65,NULL,NULL,0,0};
T150 M150={150,NULL,0,0,0};
T184 M184={184,NULL,0,0,0};
T43 M43={43,NULL,NULL};
T110 M110={110,NULL,0};
T205 M205={205,0,0,0,0,0};
T56 M56={56,NULL,0,0,0,NULL,0};
T108 M108={108,0,NULL};
T58 M58={58,NULL,0,NULL};
T66 M66={66,0,NULL,NULL,0,NULL};
T166 M166={166};
T204 M204={204,NULL,NULL};
T136 M136={136,0,0,NULL,NULL,NULL,0};
T7 M7={7,NULL,0,0};
T170 M170={170,0,NULL,NULL,0};
T55 M55={55,NULL,0};
T57 M57={57,NULL,0,0,0,NULL,0};
T127 M127={127,NULL,NULL,0,NULL,0,0};
T82 M82={82,NULL,0};
T194 M194={194,NULL,0,0,0,NULL,0};
T155 M155={155,NULL,0,0,0};
T198 M198={198,NULL,NULL,NULL};
T203 M203={203,NULL,NULL};
T94 M94={94,0,0,0,0,0,0,NULL,0,0};
T47 M47={47,NULL,NULL,NULL};
T77 M77={77,NULL,0,NULL};
T188 M188={188,0,0,0,NULL,0,0,0,0,0,0};
T93 M93={93,0,0,0,0,0,0,0,0,0,0,NULL,NULL};
T75 M75={75,0,0,0,NULL,NULL};
T23 M23={23,0,0,NULL,0,0,0};
T140 M140={140,NULL,0,0,0};
T147 M147={147,NULL,0,0,0};
T190 M190={190,NULL,NULL};
T33 M33={33,NULL,0,NULL,NULL,NULL,NULL,NULL,NULL,0,0,0,0,0,0,0,0,0};
T132 M132={132,0,NULL,NULL,0};
T180 M180={180,0,0,0,0,NULL,0};
T182 M182={182,NULL,0,0,0};
T52 M52={52,NULL,NULL,NULL};
T61 M61={61,NULL,NULL};
T200 M200={200};
T133 M133={133,0,0,0,0};
T202 M202={202,0,0,NULL};
T91 M91={91,NULL,NULL};
T112 M112={112,NULL,NULL};
T41 M41={41,0,NULL,NULL,0,NULL};
T123 M123={123,NULL,NULL};
T106 M106={106,0,NULL,NULL,0,NULL};
T79 M79={79,NULL,NULL,NULL,0};
T63 M63={63,NULL,NULL,NULL};
T117 M117={117,NULL,0,0,0};
T164 M164={164};
T218 M218={218,NULL,0};
T175 M175={175,NULL,0,0,0,NULL,0};
T74 M74={74,NULL,NULL,NULL,NULL,NULL,0,0,0,0,NULL,0,NULL};
/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT 
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of 
-- another product.
--          Copyright (C) 1994-98 LORIA - UHP - CRIN - INRIA - FRANCE
--            Dominique COLNET and Suzanne COLLIN - colnet@loria.fr 
--                       http://SmallEiffel.loria.fr
--
*/

/*
  This file (SmallEiffel/sys/runtime/boost.c) is automatically included when
  `run_control.boost' is true (ie. only for mode -boost).
*/

void se_print_run_time_stack (void) {
  fprintf(SE_ERR,"Eiffel program crash at run time.\n");
  fprintf(SE_ERR,"No trace when using option \"-boost\"\n");
}

void se_signal_handler(int sig) {
  printf("Received signal %d (man signal).\n",sig);
  se_print_run_time_stack();
  exit(EXIT_FAILURE);
}
unsigned int fsoc_count_ceil=424;
unsigned int rsoc_count_ceil=72;
/*
-- This file is  free  software, which  comes  along  with  SmallEiffel. This
-- software  is  distributed  in the hope that it will be useful, but WITHOUT 
-- ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
-- FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
-- this header is kept unaltered, and a notification of the changes is added.
-- You  are  allowed  to  redistribute  it and sell it, alone or as a part of 
-- another product.
--          Copyright (C) 1994-98 LORIA - UHP - CRIN - INRIA - FRANCE
--            Dominique COLNET and Suzanne COLLIN - colnet@loria.fr 
--                       http://SmallEiffel.loria.fr
--
*/

/* 
   This file (SmallEiffel/sys/runtime/gc_lib.c) is automatically included 
   when the Garbage Collector is used (default, unless option -no_gc has been 
   selected).
*/

static void gcna_align_mark(rsoc*c,void*o);
static rsoc*rsocfl=NULL; /* ReSizable Object Chunk Free List. */

void**stack_bottom;
mch**gcmt=NULL; /* Garbage Collector Main Table. */
int gcmt_max=2048;
int gcmt_used=0;
fsoc*fsocfl=NULL; /* Fixed Size Object Chunk Free List. */
int gc_is_off=1;
unsigned int fsoc_count=0;
unsigned int rsoc_count=0;
void*gcmt_tail_addr=NULL;

static int chunk_rounded(int size) {
  int rounded_size = size;
  int diff = rounded_size%RSOC_SIZE;

  if (diff != 0) rounded_size += (RSOC_SIZE-diff);
  return rounded_size;
}

static void free_and_remove_from_gcmt(mch* c) {
  /* Remove and free the chunk `c' from the 
   * gcmt (Garbage Collector Main Table).
   */
  mch**p=(gcmt+gcmt_used-1);
  mch*save=*p;
  mch*save2;
  p--;
  while(save != c) {
    save2 = save;
    save = *p;
    *p = save2;
    p--;
  }
  free(c);
  gcmt_used--;
}

static void may_free_rsocfl(void) {
  /* May free all chunks of `rsocfl' (ReSizable Object Chunk Free List) 
     in some circumstances.
  */
  rsoc* next, *current;
  int count = rsocfl_count();
  if ((count > 50) && (count > (rsoc_count >> 1))) {
    current=rsocfl;
    rsocfl=NULL;
    while (current != NULL) {
      next=current->next;
      if (current->isize == current->header.size) {
	free_and_remove_from_gcmt(((mch*)current));
	rsoc_count--;
      }
      else {
	current->next=rsocfl;
	rsocfl=current;
      }
      current = next;
    }
  }
}

void gc_sweep(void) {
  mch** p2 = gcmt;
  mch** p1 = gcmt+1;
  mch**eogcmt=gcmt+gcmt_used;
  if (FREE_CHUNK((*p2)->state_type)) {
    if (RSO_FREE_CHUNK == ((*p2)->state_type)) {
      ((rsoc*)(*p2))->next=NULL;
      rsocfl=((rsoc*)(*p2));
    }
    else {
      rsocfl=NULL;
    }	
  }
  else {
    ((*gcmt)->swfp)(*p2);
    if (RSO_FREE_CHUNK==((*p2)->state_type)) {
      ((rsoc*)(*p2))->next=NULL;
      rsocfl=((rsoc*)(*p2));
    }
    else {
      rsocfl=NULL;
    }
  }
  while (p1 < eogcmt) {
    if (FREE_CHUNK((*p1)->state_type)) {
      if (RSO_FREE_CHUNK == ((*p1)->state_type)) {
	if (RSO_FREE_CHUNK == ((*p2)->state_type)) {
	  if (((char*)(*p2))+(*p2)->size == ((char*)(*p1))) {
	    ((*p2)->size)+=((*p1)->size);
	    p1++;
	  }
	  else {
	    ((rsoc*)(*p1))->next=rsocfl;
	    rsocfl=((rsoc*)(*p1));
	    *(p2+1)=*p1; p2++; p1++;
	  }
	}
	else {
	  ((rsoc*)(*p1))->next=rsocfl;
	  rsocfl=((rsoc*)(*p1));
	  *(p2+1)=*p1; p2++; p1++;
	}
      }
      else {
	*(p2+1)=*p1; p2++; p1++;
      }
    }
    else {
      ((*p1)->swfp)(*p1);
      if (RSO_FREE_CHUNK == ((*p1)->state_type)) {
	if (RSO_FREE_CHUNK == ((*p2)->state_type)) {
	  if (((char*)(*p2))+(*p2)->size == ((char*)(*p1))) {
	    ((*p2)->size)+=((*p1)->size);
	    p1++;
	  }
	  else {
	    ((rsoc*)(*p1))->next=rsocfl;
	    rsocfl=((rsoc*)(*p1));
	    *(p2+1)=*p1; p2++; p1++;
	  }
	}
	else {
	  ((rsoc*)(*p1))->next=rsocfl;
	  rsocfl=((rsoc*)(*p1));
	  *(p2+1)=*p1; p2++; p1++;
	}
      }
      else {
	*(p2+1)=*p1; p2++; p1++;
      }
    }
  }
  gcmt_used=(p2-gcmt)+1;
  may_free_rsocfl();
}

void gc_mark(void*p) {
  if ((p>((void*)*gcmt))&&(p<=gcmt_tail_addr)) {
    int i1=0;
    int i2=gcmt_used-1;
    int m=i2>>1;
    mch*c;
    for (;i2>i1;m=((i1+i2)>>1)) {
      if (p<=((void*)gcmt[m+1])) {
	i2=m;
      }
      else {
	i1=m+1;
      }
    }
    c=gcmt[i2];
    if (!(FREE_CHUNK(c->state_type))) {
      (c->amfp)(c,p);
    }
  }
}

int gc_stack_size(void) {
  void*stack_top[2]={NULL,NULL};
  if (stack_top > stack_bottom) {
    return ((void**)stack_top)-((void**)stack_bottom);
  }
  else {
    return ((void**)stack_bottom)-((void**)stack_top);
  }
}

/*
  To delay Garbage Collection when the stack is too large.
  To allow fast increase of ceils.
*/
#define FSOC_LIMIT (10240/((FSOC_SIZE)>>10))
#define RSOC_LIMIT (10240/((RSOC_SIZE)>>10)) 

/*
  When stack is too large, collection may be delayed.
*/
#define GCLARGESTACK 50000

int garbage_delayed(void) {
  /*
    To delay the first GC call.
  */
  if (gc_stack_size() > GCLARGESTACK) {
    if (fsoc_count_ceil <= fsoc_count) {
      if (rsoc_count_ceil <= rsoc_count) {
	if ((fsoc_count<FSOC_LIMIT)&&(rsoc_count<RSOC_LIMIT)) {
	  fsoc_count_ceil++;
	  rsoc_count_ceil++;
	  return 1;
	}
	else return 0;
      }
      else {
	if (fsoc_count<FSOC_LIMIT) {
	  fsoc_count_ceil++;
	  return 1;
	}
	else return 0;
      }
    }
    else {
      if (rsoc_count_ceil <= rsoc_count) {
	if (rsoc_count<RSOC_LIMIT) {
	  rsoc_count_ceil++;
	  return 1;
	}
	else return 0;
      }
      else return 0;
    }
  }
  else {
    return 0;
  }
}

void gc_update_ceils(void) {
  int c;

  /* Compute fsoc_count_ceil :
   */
  if (fsocfl==NULL) {
    if (fsoc_count >= fsoc_count_ceil) {
      if (fsoc_count_ceil<FSOC_LIMIT) {
	fsoc_count_ceil<<=1;
      }
      else { 
	c=fsoc_count+(fsoc_count/3);
	if (fsoc_count_ceil < c)
	  fsoc_count_ceil=c;
      }
    }
  }
  else
    if (fsoc_count_ceil < fsoc_count)
      fsoc_count_ceil=fsoc_count;
  /* Compute rsoc_count_ceil :
   */
  if (rsocfl==NULL) {
    if (rsoc_count>=rsoc_count_ceil) {
      if (rsoc_count_ceil<RSOC_LIMIT) {
	rsoc_count_ceil<<=1;
      }
      else { 
	c=rsoc_count+(rsoc_count/3);
	if (rsoc_count_ceil < c)
	  rsoc_count_ceil=c;
      }
    }
  }
  else
    if (rsoc_count_ceil < rsoc_count)
      rsoc_count_ceil=rsoc_count;
}

static void gc_add_into_gcmt(mch*c) {
  /* Update the `gcmt' (Garbage Collector Main Table) by adding the 
     new `mch' (Memory Chunk Header).
  */
  mch** p;
  if (gcmt_used == gcmt_max) {
    gcmt_max <<= 1;
    gcmt = ((mch**)(realloc(gcmt,(gcmt_max+1)*sizeof(void*))));
  }
  for (p=gcmt+(gcmt_used++ -1) ; (p>=gcmt)&&(*p>c) ; p--) {
    *(p+1) = *p;
  }
  *(p+1) = c;
}

static char*rso_from_store(na_env*nae,int size) {
  rsoh*r=(nae->store);
  nae->store_left-=size;
  if ((nae->store_left) > sizeof(rsoh)) {
    r->header.size=size;
    nae->store=((rsoh*)(((char*)(nae->store))+size));
  }
  else {
    r->header.size=size+nae->store_left;
    nae->store_left=0;
  }
  (r->header.magic_flag)=RSOH_UNMARKED;
  ((void)memset((r+1),0,r->header.size-sizeof(rsoh)));
  return (char*)(r+1);
}

static void rsoc_sweep(rsoc*c) {
  na_env*nae=c->nae;
  rsoh*gp=(rsoh*)&(c->first_header);
  rsoh*pp;
  rsoh*eoc=((rsoh*)(((char*)c)+c->header.size));
  c->free_list_of_large=NULL;
  if (c->header.size > RSOC_SIZE) {
    if (gp->header.magic_flag == RSOH_MARKED) {
      gp->header.magic_flag=RSOH_UNMARKED;
      c->next=nae->chunk_list;
      nae->chunk_list=c;
    }
    else {
      c->header.state_type=RSO_FREE_CHUNK;
    }
    return;
  }
  while (gp<eoc) {
    while (gp->header.magic_flag == RSOH_MARKED) {
      gp->header.magic_flag=RSOH_UNMARKED;
      gp=((rsoh*)(((char*)gp)+gp->header.size));
      if(gp>=eoc) {
	c->next=nae->chunk_list;
	nae->chunk_list=c;
	return;
      }
    }
    gp->header.magic_flag=RSOH_FREE;
    pp=(rsoh*)(((char*)gp)+gp->header.size);
    while ((pp<eoc)&&(pp->header.magic_flag != RSOH_MARKED)) {
      pp->header.magic_flag=RSOH_FREE;
      gp->header.size+=pp->header.size;
      pp=((rsoh*)(((char*)pp)+pp->header.size));
    }
    if (gp->header.size >= RSOC_MIN_STORE) {
      if (nae->store_left==0) {
	nae->store_left=gp->header.size;
	nae->store=gp;
	nae->store_chunk=c;
      }
      else if (nae->store->header.size < gp->header.size) {
	((fll_rsoh*)nae->store)->nextflol=nae->store_chunk->free_list_of_large;
	nae->store_chunk->free_list_of_large=((fll_rsoh*)nae->store);
	nae->store_left=gp->header.size;
	nae->store=gp;
	nae->store_chunk=c;
      }
      else {
	((fll_rsoh*)gp)->nextflol=c->free_list_of_large;
	c->free_list_of_large=((fll_rsoh*)gp);
      }
    }
    gp=pp;
  }
  if (((rsoh*)(&c->first_header))->header.size >= 
      (c->header.size-sizeof(rsoc)+sizeof(rsoh))){
    c->header.state_type=RSO_FREE_CHUNK;
    nae->store_chunk=NULL;
    nae->store_left=0; 
  }
  else{
    c->next=nae->chunk_list;
    nae->chunk_list=c;
  }
}

static const rsoc MRSOC = {
    {
	RSOC_SIZE,
	RSO_USED_CHUNK,
	((void(*)(mch*,void*))gcna_align_mark),
	((void(*)(mch*))rsoc_sweep)
    },
    0,
    NULL,
    NULL,
    NULL,
    {
      {
	0,
	RSOH_MARKED
      }
    }
};

static void rsoc_malloc(na_env*nae) {
  rsoc* r = ((rsoc*)(se_malloc(RSOC_SIZE)));
  rsoc_count++;
  *r=MRSOC;
  r->nae=nae;
  r->isize=RSOC_SIZE;
  nae->store=(&(r->first_header));
  nae->store_left=RSOC_SIZE-sizeof(rsoc)+sizeof(rsoh);
  nae->store_chunk=r;
  r->next=nae->chunk_list;
  nae->chunk_list=r;
  gc_add_into_gcmt((mch*)r);
}

static rsoc* rsocfl_best_fit(int size) {
  int best_size = 0;
  rsoc *pc,*best_pc,*best_c, *c;
  if (rsocfl==NULL)
    return NULL;
  pc=NULL;
  best_pc=NULL;
  best_c=NULL;
  c=rsocfl;
  while ((NULL!=c)&&(NULL==best_c)){
    if (c->header.size>=size){
      best_c=c;
      best_pc=pc;
      best_size=c->header.size;
    }
    pc=c;
    c=c->next;
  }
  if (NULL==c){
    if (best_pc != NULL)
      best_pc->next=best_c->next;
    else if (best_c==rsocfl)
      rsocfl=best_c->next;
    return best_c;
  }
  do {
    if ((c->header.size >= size) && (c->header.size < best_size)) {	
      best_c = c;
      best_pc = pc;
      best_size = c->header.size;
    }
    pc=c;
    c=c->next;
  } 
  while(c!=NULL);
  if (NULL==best_pc) {
    rsocfl = best_c->next;
  }
  else {
    best_pc->next=best_c->next;
  }
  return best_c;
}

static int get_store_in(rsoc*c,int size) {
  na_env*nae=c->nae;
  fll_rsoh*pf=NULL;
  fll_rsoh*f=c->free_list_of_large;
  while (f != NULL) {
    if (f->rsoh_field.size >= size) {
      nae->store_left=f->rsoh_field.size;
      nae->store=(rsoh*)f;
      nae->store_chunk=c;
      if (pf == NULL) {
	c->free_list_of_large=f->nextflol;
      }
      else {
	pf->nextflol=f->nextflol;
      }
      return 1;
    }
    pf = f;
    f = f->nextflol;
  }
  return 0;
}

char*new_na_from_chunk_list(na_env*nae,int size) {
  rsoc*c=nae->chunk_list;
  int csize;
  while (c != NULL) {
    if (get_store_in(c,size)) {
      return rso_from_store(nae,size);
    }	
    c = c->next;
  }
  csize=size+(sizeof(rsoc)-sizeof(rsoh));
  c=rsocfl_best_fit(csize);
  if (c != NULL){
    if ((c->header.size > RSOC_SIZE)
	&&
	(c->header.size-csize > RSOC_MIN_STORE*4)) {
      int csize_left=c->header.size-csize;
      if ((csize_left%sizeof(double))!=0) {
	csize_left-=(csize_left%sizeof(double));
	csize=c->header.size-csize_left;
      }
      c->header.size=csize_left;
      c->next=rsocfl;
      rsocfl=c;
      c=(rsoc*)(((char*)c)+csize_left);
      gc_add_into_gcmt((mch*)c);
      c->header.amfp=(void(*)(mch*,void*))gcna_align_mark;
      c->header.swfp=(void(*)(mch*))rsoc_sweep;
    }
    else {
      csize=c->header.size;
    }
    c->header.size=csize;
    c->header.state_type=RSO_USED_CHUNK;
    c->free_list_of_large=NULL;
    c->nae=nae;
    nae->store=(&(c->first_header));
    nae->store_left=csize-sizeof(rsoc)+sizeof(rsoh);
    nae->store_chunk=c;
    c->next=nae->chunk_list;
    nae->chunk_list=c;
    return rso_from_store(nae,size);
  }
  return NULL;
}

char*new_na(na_env*nae,int size) { 
  if (nae->store_left>0) {
    nae->store->header.size=nae->store_left;
    nae->store->header.magic_flag=RSOH_FREE;
    if (nae->store_left >= RSOC_MIN_STORE) {
      ((fll_rsoh*)(nae->store))->nextflol=nae->store_chunk->free_list_of_large;
      nae->store_chunk->free_list_of_large=((fll_rsoh*)nae->store);
    }
    nae->store_left=0;
  }
  if ((nae->store_chunk!=NULL)&&(get_store_in(nae->store_chunk,size))) {
    return rso_from_store(nae,size);
  }
  {
    char*r=new_na_from_chunk_list(nae,size);
    if (r!=NULL)
      return r;
  }
  if (rsoc_count<rsoc_count_ceil) {
    if((size+sizeof(rsoc)-sizeof(rsoh))>RSOC_SIZE){
      rsoc*c;
      rsoh*r;
      int rounded_size = chunk_rounded(size+sizeof(rsoc)-sizeof(rsoh));
      c=((rsoc*)(se_malloc(rounded_size)));
      r=(&(c->first_header));
      rsoc_count++;
      *c=MRSOC;
      c->isize = rounded_size;
      c->header.size=rounded_size;
      c->nae=nae;
      c->next=nae->chunk_list;
      nae->chunk_list=c;
      gc_add_into_gcmt((mch*)c);
      r->header.size=size;
      (r->header.magic_flag)=RSOH_UNMARKED;
      ((void)memset((r+1),0,size-sizeof(rsoh)));
      return (char*)(r+1);
    }
    else {
      rsoc_malloc(nae);
#ifdef GC_DEBUG
      printf("na from rsoc_malloc 1 (%i)\n",size);
#endif
      return rso_from_store(nae,size);
    }
  }
  gc_start();
  if (size<=(nae->store_left)) {
    return rso_from_store(nae,size);
  }
  {
    char*r=new_na_from_chunk_list(nae,size);
    if (r!=NULL) {
      return r;
    }
  }
  if((size+sizeof(rsoc)-sizeof(rsoh))>RSOC_SIZE){
    rsoc*c;
    rsoh*r;
    int rounded_size = chunk_rounded(size+sizeof(rsoc)-sizeof(rsoh));
    c=((rsoc*)(se_malloc(rounded_size)));
    r=(&(c->first_header));
    rsoc_count++;
    *c=MRSOC;
    c->isize = rounded_size;
    c->header.size=rounded_size;
    c->nae=nae;
    c->next=nae->chunk_list;
    nae->chunk_list=c;
    gc_add_into_gcmt((mch*)c);
    r->header.size=size;
    (r->header.magic_flag)=RSOH_UNMARKED;
    ((void)memset((r+1),0,size-sizeof(rsoh)));
    gc_update_ceils();
    return (char*)(r+1);
  }
  else {
    rsoc_malloc(nae);
    gc_update_ceils();
    return rso_from_store(nae,size);
  }
}

static void gcna_align_mark(rsoc*c,void*o) {
  na_env* nae = c->nae;
  fll_rsoh* f;
  fll_rsoh* pf;
  char* b = (char*)&(c->first_header);
  /* out of the chunck 'c' ? */
  if (((char*)o) > (((char*)c)+c->header.size)) {
      return;
  }
  /* properly aligned ? */
  if (((((char*)o)-((char*)c))%sizeof(int)) != 0) {
      return;
  }
  /* already marked ? */
  if ((((rsoh*)o)-1)->header.magic_flag != RSOH_UNMARKED) {
      return;
  }
  if (((char*)o) < ((char*)(c+1))) {
      return;
  }
  /* a large chunck ? */
  if (c->header.size > RSOC_SIZE) {
      if (o == (c+1)) {
	nae->gc_mark((T0*)o);
      }
      return;
  }
  pf=NULL;
  f=c->free_list_of_large;
  while ((f != NULL) && (f < ((fll_rsoh*)o))) {
      pf=f;
      f=f->nextflol;
  }
  if (pf == NULL) {
      pf=(fll_rsoh*)b;
  }
  while ((((rsoh*)pf)+1) < (rsoh*)o) {
      pf = ((fll_rsoh*)(((char*)pf)+pf->rsoh_field.size));
  }
  if (o == (((rsoh*)pf)+1)) {
    nae->gc_mark((T0*)o);
  } 
}

int rsocfl_count(void) {
  /* Returns the number of items in the ReSizable Object Free List.
  */
  int r=0;
  rsoc*p=rsocfl;
  while (p!=NULL) {
    r++;
    p=p->next;
  }
  return r;
}

int fsocfl_count(void) {
  int r=0;
  fsoc*p=fsocfl;
  while (p!=NULL) {
    r++;
    p=p->next;
  }
  return r;
}

void gc_dispose_before_exit(void) {
  mch** p = gcmt;
  mch**eogcmt=gcmt+gcmt_used;
    
  while (p < eogcmt) {
    if (((*p)->state_type == FSO_STORE_CHUNK) || 
	((*p)->state_type == FSO_USED_CHUNK)) {
      ((*p)->swfp)(*p);
    }
    p++;
  }
}

fsoc* gc_fsoc_get1(void) {
  /* Get a `fsoc' (Fixed Size Object Chunk) from the free fsoc list or
     allocate a new one (using `se_malloc') only when the ceil is not 
     yet reached. Otherwise, call the `gc_start()' function and 
     return NULL.
  */
  fsoc* result;
  if (fsocfl != NULL) {
    result = fsocfl;
    fsocfl = fsocfl->next;
    return result;
  }
  else if (fsoc_count_ceil > fsoc_count) {
    result = ((fsoc*)se_malloc(FSOC_SIZE));
    fsoc_count++;
    gc_add_into_gcmt((mch*)result);
    return result;
  }
  else {
    gc_start();
    return NULL;
  }
}

fsoc* gc_fsoc_get2(void) {
  /* Get a `fsoc' (Fixed Size Object Chunk) or force the allocation of a 
     new `fsoc' (using the `se_malloc' function). Update various ceils 
     accordingly.
  */
  fsoc* result;
  if (fsocfl != NULL) {
    result = fsocfl;
    fsocfl=fsocfl->next;
    return result;
  }
  else {
    result = ((fsoc*)(se_malloc(FSOC_SIZE)));
    gc_update_ceils();
    fsoc_count++;
    gc_add_into_gcmt((mch*)result);
    return result;
  }
}

unsigned int gc_start_count=0;
T0*oBC8string_buffer=NULL;


T2 r8hash_code(T8 C){
T2 R=0;
T9 _storage=NULL;
_storage=(/*RF2*/((T7*)(oBC8string_buffer))->_storage/*4*/);
{void*p=C;
sprintf(((char*)_storage),"%p",p);}
r7from_external((T7*)(oBC8string_buffer),((void*)(_storage)));
R=r7hash_code((T7*)(oBC8string_buffer));
return R;
}


T6 r6_ix_not(T6 C){
T6 R=0;
/*[IF*/
if(C){
}
else{
R=1;
}
/*FI]*/
return R;
}


T6 r3_px_6061(T3 C,T3 a1){
T6 R=0;
R=(T3code(C))<=(T3code(a1));
return R;
}


T6 r3is_digit(T3 C){
T6 R=0;
/*[IF*/
if((((unsigned)(C))>=((unsigned)(((T3)'0'))))){
R=(((unsigned)(C))<=((unsigned)(((T3)'9'))));
}
/*FI]*/
return R;
}


T6 r3is_hexadecimal_digit(T3 C){
T6 R=0;
/*[IF*/
if(r3is_digit(C)){
R=1;
}
 else if((((unsigned)(C))>=((unsigned)(((T3)'a'))))){
R=(((unsigned)(C))<=((unsigned)(((T3)'f'))));
}
 else if((((unsigned)(C))>=((unsigned)(((T3)'A'))))){
R=(((unsigned)(C))<=((unsigned)(((T3)'F'))));
}
/*FI]*/
return R;
}


T6 r3_px_6261(T3 C,T3 a1){
T6 R=0;
R=(T3code(C))>=(T3code(a1));
return R;
}


T2 r3value(T3 C){
T2 R=0;
R=(T3code(C))-(48);
return R;
}


T2 r3hexadecimal_value(T3 C){
T2 R=0;
/*[IF*/
if((T3code(C))<(T3code(((T3)'A')))){
R=(T3code(C))-(48);
}
 else if((T3code(C))<(T3code(((T3)'a')))){
R=(T3code(C))-(55);
}
else{
R=(T3code(C))-(87);
}
/*FI]*/
return R;
}


T6 r2is_equal(T2 C,T2 a1){
T6 R=0;
R=(!((C)<(a1)))&&(!((a1)<(C)));
return R;
}


T0* r2to_string(T2 C){
T0* R=NULL;
/*[IRF3.3clear*/((((T7*)((T7*)(oBC2tmp_string))))->_count/*8*/)=(0);
/*]*/
r2append_in(C,oBC2tmp_string);
R=r7twin((T7*)(oBC2tmp_string));
return R;
}
T0*oBC2tmp_string=NULL;


T3 r2digit(T2 C){
T3 R=0;
R=((T3)((C)+(T3code(((T3)'0')))));
return R;
}


T2 r2hash_code(T2 C){
T2 R=0;
/*[IF*/
if((C)<(0)){
R=-((C)+(1));
}
else{
R=C;
}
/*FI]*/
return R;
}


void r2append_in(T2 C,T0* a1){
T2 _i=0;
T2 _val=0;
/*[IF*/
if((C)==(0)){
r7extend(((T7*)a1),((T3)'0'));
}
else{
/*[IF*/
if((C)>(0)){
_i=((/*RF2*/(((T7*)a1))->_count/*8*/))+(1);
_val=C;
while (!((_val)==(0)))
{
r7extend(((T7*)a1),r2digit((_val)%(10)));
_val=(_val)/(10);
}
}
else{
r7extend(((T7*)a1),((T3)'\55'));
_i=((/*RF2*/(((T7*)a1))->_count/*8*/))+(1);
_val=C;
while (!((_val)==(0)))
{
r7extend(((T7*)a1),r2digit(-((_val)%(10))));
_val=(_val)/(10);
}
}
/*FI]*/
_val=(/*RF2*/(((T7*)a1))->_count/*8*/);
while (!((_i)>=(_val)))
{
r7swap(((T7*)a1),_i,_val);
_val=(_val)-(1);
_i=(_i)+(1);
}
}
/*FI]*/
}


T3 r2hexadecimal_digit(T2 C){
T3 R=0;
/*[IF*/
if((C)<=(9)){
R=r2digit(C);
}
else{
R=((T3)((T3code(((T3)'A')))+((C)-(10))));
}
/*FI]*/
return R;
}


T2 r5sign(T5 C){
T2 R=0;
/*[IF*/
if(((/*RF2*/C))<(T4toT5(0.0))){
R=-(1);
}
 else if(((/*RF2*/C))>(T4toT5(0.0))){
R=1;
}
/*FI]*/
return R;
}


T0* r5to_string(T5 C){
T0* R=NULL;
{T7*n=new7();
r7make(n,8);
R=((T0*)n);
}
/*[IRF3.6append_in*/{T5 C1=C;
T0* b1=R;
r5append_in_format(C1,b1,6);
}/*]*/
return R;
}


T5 r5double_ceiling(T5 C){
T5 R=0;
R=ceil(C);
return R;
}


T2 r5rounded(T5 C){
T2 R=0;
/*[IF*/
if(((floor(C))+(T4toT5(0.5)))<(C)){
R=((int)floor(r5double_ceiling(C)));
}
else{
R=((int)floor(floor(C)));
}
/*FI]*/
return R;
}
T9 oBC5sprintf_double_buffer=NULL;
int fBC5sprintf_double_buffer=0;


T9 r5sprintf_double_buffer(void){
if(fBC5sprintf_double_buffer==0){fBC5sprintf_double_buffer=1;{
oBC5sprintf_double_buffer=new9(1024);
}}
return oBC5sprintf_double_buffer;
}


void r5append_in_format(T5 C,T0* a1,T2 a2){
T2 _i=0;
{/*sprintf_double*/
char fmt[32];
double d=C;
fmt[0]='%';
fmt[1]='.';
sprintf(fmt+2,"%df\0",(a2));
sprintf(((char*)(r5sprintf_double_buffer())),fmt,d);
}
_i=0;
while (!(((r5sprintf_double_buffer())[_i])==(((T3)'\0'))))
{
r7extend(((T7*)a1),(r5sprintf_double_buffer())[_i]);
_i=(_i)+(1);
}
}


T5 r4pow(T4 C,T5 a1){
T5 R=0;
R=pow(((T5)(C)),a1);
return R;
}


T0* r4to_string(T4 C){
T0* R=NULL;
R=r5to_string(((T5)(C)));
return R;
}


T2 r4rounded(T4 C){
T2 R=0;
R=r5rounded(((T5)(C)));
return R;
}


void r157set_all_with(T157 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r157copy_from(T157 C,T157 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}


void r149set_all_with(T149 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r149copy_from(T149 C,T149 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}


void r161set_all_with(T161 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r139set_all_with(T139 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r139copy_from(T139 C,T139 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}


void r169set_all_with(T169 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r169copy_from(T169 C,T169 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}


void r118set_all_with(T118 C,T5 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r118copy_from(T118 C,T118 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}


void r152set_all_with(T152 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r152copy_from(T152 C,T152 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}


void r59set_all_with(T59 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r99set_all_with(T99 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r142set_all_with(T142 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r142copy_from(T142 C,T142 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}


void r181clear_all(T181 C,T2 a1){
T2 _i=0;
T0* _v=NULL;
_i=a1;
while (!((_i)<(0)))
{
(C)[_i]=(_v);
_i=(_i)-(1);
}
}


void r181set_all_with(T181 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r181copy_from(T181 C,T181 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}


void r174set_all_with(T174 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r174copy_from(T174 C,T174 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}


void r78set_all_with(T78 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r177set_all_with(T177 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


T9 r9realloc(T9 C,T2 a1,T2 a2){
T9 R=NULL;
R=new9(a2);
r9copy_from(R,C,(a1)-(1));
return R;
}


void r9set_all_with(T9 C,T3 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


T6 r9fast_memcmp(T9 C,T9 a1,T2 a2){
T6 R=0;
T2 _i=0;
_i=(a2)-(1);
while (!(((_i)<(0))||(((C)[_i])!=((a1)[_i]))))
{
_i=(_i)-(1);
}
R=(_i)<(0);
return R;
}


void r9copy_at(T9 C,T2 a1,T9 a2,T2 a3){
T2 _i2=0;
T2 _i1=0;
_i1=a1;
while (!((_i2)==(a3)))
{
(C)[_i1]=((a2)[_i2]);
_i2=(_i2)+(1);
_i1=(_i1)+(1);
}
}


void r9copy_from(T9 C,T9 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}


void r64set_all_with(T64 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r199set_all_with(T199 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r48set_all_with(T48 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r154set_all_with(T154 C,T0* a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r154copy_from(T154 C,T154 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}


void r145set_all_with(T145 C,T2 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=(a1);
_i=(_i)-(1);
}
}


void r145copy_from(T145 C,T145 a1,T2 a2){
T2 _i=0;
_i=a2;
while (!((_i)<(0)))
{
(C)[_i]=((a1)[_i]);
_i=(_i)-(1);
}
}


void r7copy(T7* C,T0* a1){
(/*SFN*/C->_count/*8*/)=(/*RF2*/(((T7*)a1))->_count/*8*/);
/*[IF*/
if(((/*RF2*/(C)->_count/*8*/))>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*12*/))<((/*RF2*/(C)->_count/*8*/))){
(/*SFN*/C->_storage/*4*/)=new9((/*RF2*/(C)->_count/*8*/));
(/*SFN*/C->_capacity/*12*/)=(/*RF2*/(C)->_count/*8*/);
}
/*FI]*/
r9copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T7*)a1))->_storage/*4*/),((/*RF2*/(C)->_count/*8*/))-(1));
}
/*FI]*/
}


T6 r7is_equal(T7* C,T0* a1){
T6 R=0;
/*[IF*/
if(((/*RF2*/(C)->_count/*8*/))==((/*RF2*/(((T7*)a1))->_count/*8*/))){
R=r9fast_memcmp((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T7*)a1))->_storage/*4*/),(/*RF2*/(C)->_count/*8*/));
}
/*FI]*/
return R;
}


void r7append(T7* C,T0* a1){
T2 _new_capacity=0;
T2 _needed_capacity=0;
T2 _s_count=0;
_s_count=(/*RF2*/(((T7*)a1))->_count/*8*/);
_needed_capacity=((/*RF2*/(C)->_count/*8*/))+(_s_count);
/*[IF*/
if((_needed_capacity)>((/*RF2*/(C)->_capacity/*12*/))){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*12*/))==(0)){
(/*SFN*/C->_storage/*4*/)=new9(_needed_capacity);
(/*SFN*/C->_capacity/*12*/)=_needed_capacity;
}
else{
_new_capacity=(2)*((/*RF2*/(C)->_capacity/*12*/));
/*[IF*/
if((_needed_capacity)>(_new_capacity)){
(/*SFN*/C->_storage/*4*/)=r9realloc((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(C)->_capacity/*12*/),_needed_capacity);
(/*SFN*/C->_capacity/*12*/)=_needed_capacity;
}
else{
(/*SFN*/C->_storage/*4*/)=r9realloc((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(C)->_capacity/*12*/),_new_capacity);
(/*SFN*/C->_capacity/*12*/)=_new_capacity;
}
/*FI]*/
}
/*FI]*/
}
/*FI]*/
r9copy_at((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(C)->_count/*8*/),(/*RF2*/(((T7*)a1))->_storage/*4*/),_s_count);
(/*SFN*/C->_count/*8*/)=_needed_capacity;
}


void r7make(T7* C,T2 a1){
/*[IF*/
if((a1)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*12*/))<(a1)){
(/*SFN*/C->_storage/*4*/)=new9(a1);
(/*SFN*/C->_capacity/*12*/)=a1;
}
/*FI]*/
}
/*FI]*/
(/*SFN*/C->_count/*8*/)=0;
}


void r7extend(T7* C,T3 a1){
T2 _new_capacity=0;
/*[IF*/
if(((/*RF2*/(C)->_capacity/*12*/))>((/*RF2*/(C)->_count/*8*/))){
}
 else if(((/*RF2*/(C)->_capacity/*12*/))==(0)){
(/*SFN*/C->_capacity/*12*/)=32;
(/*SFN*/C->_storage/*4*/)=new9((/*RF2*/(C)->_capacity/*12*/));
}
else{
_new_capacity=(2)*((/*RF2*/(C)->_capacity/*12*/));
(/*SFN*/C->_storage/*4*/)=r9realloc((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(C)->_capacity/*12*/),_new_capacity);
(/*SFN*/C->_capacity/*12*/)=_new_capacity;
}
/*FI]*/
((/*RF2*/(C)->_storage/*4*/))[(/*RF2*/(C)->_count/*8*/)]=(a1);
(/*SFN*/C->_count/*8*/)=((/*RF2*/(C)->_count/*8*/))+(1);
}


T0* r7_px_43(T7* C,T0* a1){
T0* R=NULL;
{T7*n=new7();
r7make(n,((/*RF2*/(C)->_count/*8*/))+((/*RF2*/(((T7*)a1))->_count/*8*/)));
R=((T0*)n);
}
r7append(((T7*)R),(T0*)C);
r7append(((T7*)R),a1);
return R;
}


T2 r7hash_code(T7* C){
T2 R=0;
T2 _j=0;
T2 _i=0;
_j=(/*RF2*/(C)->_count/*8*/);
_i=1;
while (!((_j)<=(0)))
{
R=((5)*(R))+(T3code(/*(IRF4.6item*/((/*RF2*/(C)->_storage/*4*/))[(_i)-(1)]/*)*/));
_i=(_i)+(1);
_j=(_j)-(1);
}
/*[IF*/
if((R)<(0)){
R=-((R)+(1));
}
/*FI]*/
return R;
}


void r7remove_last(T7* C,T2 a1){
(/*SFN*/C->_count/*8*/)=((/*RF2*/(C)->_count/*8*/))-(a1);
}


void r7append_character(T7* C,T3 a1){
T2 _new_capacity=0;
/*[IF*/
if(((/*RF2*/(C)->_capacity/*12*/))>((/*RF2*/(C)->_count/*8*/))){
}
 else if(((/*RF2*/(C)->_capacity/*12*/))==(0)){
(/*SFN*/C->_capacity/*12*/)=32;
(/*SFN*/C->_storage/*4*/)=new9((/*RF2*/(C)->_capacity/*12*/));
}
else{
_new_capacity=(2)*((/*RF2*/(C)->_capacity/*12*/));
(/*SFN*/C->_storage/*4*/)=r9realloc((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(C)->_capacity/*12*/),_new_capacity);
(/*SFN*/C->_capacity/*12*/)=_new_capacity;
}
/*FI]*/
((/*RF2*/(C)->_storage/*4*/))[(/*RF2*/(C)->_count/*8*/)]=(a1);
(/*SFN*/C->_count/*8*/)=((/*RF2*/(C)->_count/*8*/))+(1);
}


void r7add_last(T7* C,T3 a1){
T2 _new_capacity=0;
/*[IF*/
if(((/*RF2*/(C)->_capacity/*12*/))>((/*RF2*/(C)->_count/*8*/))){
}
 else if(((/*RF2*/(C)->_capacity/*12*/))==(0)){
(/*SFN*/C->_capacity/*12*/)=32;
(/*SFN*/C->_storage/*4*/)=new9((/*RF2*/(C)->_capacity/*12*/));
}
else{
_new_capacity=(2)*((/*RF2*/(C)->_capacity/*12*/));
(/*SFN*/C->_storage/*4*/)=r9realloc((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(C)->_capacity/*12*/),_new_capacity);
(/*SFN*/C->_capacity/*12*/)=_new_capacity;
}
/*FI]*/
((/*RF2*/(C)->_storage/*4*/))[(/*RF2*/(C)->_count/*8*/)]=(a1);
(/*SFN*/C->_count/*8*/)=((/*RF2*/(C)->_count/*8*/))+(1);
}


void r7from_external_copy(T7* C,T8 a1){
T2 _i=0;
T9 _s=NULL;
_s=a1;
(/*SFN*/C->_count/*8*/)=0;
while (!(((_s)[_i])==(((T3)'\0'))))
{
r7append_character(C,(_s)[_i]);
_i=(_i)+(1);
}
}


void r7from_external(T7* C,T8 a1){
(/*SFN*/C->_storage/*4*/)=a1;
(/*SFN*/C->_count/*8*/)=0;
while (!((((/*RF2*/(C)->_storage/*4*/))[(/*RF2*/(C)->_count/*8*/)])==(((T3)'\0'))))
{
(/*SFN*/C->_count/*8*/)=((/*RF2*/(C)->_count/*8*/))+(1);
}
(/*SFN*/C->_capacity/*12*/)=((/*RF2*/(C)->_count/*8*/))+(1);
}


T8 r7to_external(T7* C){
T8 R=NULL;
/*[IF*/
if(((/*RF2*/(C)->_capacity/*12*/))>((/*RF2*/(C)->_count/*8*/))){
(/*SFN*/C->_count/*8*/)=((/*RF2*/(C)->_count/*8*/))+(1);
/*[IF*/
if((/*(IRF4.6item*/((/*RF2*/(C)->_storage/*4*/))[((/*RF2*/(C)->_count/*8*/))-(1)]/*)*/)!=(((T3)'\0'))){
/*[IRF3.5put*/((/*RF2*/(C)->_storage/*4*/))[((/*RF2*/(C)->_count/*8*/))-(1)]=(((T3)'\0'));
/*]*/
}
/*FI]*/
}
else{
r7append_character(C,((T3)'\0'));
}
/*FI]*/
(/*SFN*/C->_count/*8*/)=((/*RF2*/(C)->_count/*8*/))-(1);
R=((void*)((/*RF2*/(C)->_storage/*4*/)));
return R;
}


T0* r7twin(T7* C){
T0* R=NULL;
R=((void*)new7());
r7copy(((T7*)R),((T0*)C));
return R;
}


void r7swap(T7* C,T2 a1,T2 a2){
T3 _tmp=0;
_tmp=/*(IRF4.6item*/((/*RF2*/(C)->_storage/*4*/))[(a1)-(1)]/*)*/;
/*[IRF3.5put*/((/*RF2*/(C)->_storage/*4*/))[(a1)-(1)]=(/*(IRF4.6item*/((/*RF2*/(C)->_storage/*4*/))[(a2)-(1)]/*)*/);
/*]*/
/*[IRF3.5put*/((/*RF2*/(C)->_storage/*4*/))[(a2)-(1)]=(_tmp);
/*]*/
}


void r131copy(T131* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T131*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T131*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
(/*SFN*/C->_storage/*4*/)=new154((/*RF2*/(C)->_capacity/*8*/));
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r154copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T131*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}


T2 r131count(T131* C){
T2 R=0;
R=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
return R;
}


T0* r131item(T131* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}


void r131make(T131* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new154(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
/*[IRF3.6clear_all*/{T131* C1=C;
T0* __value=NULL;
/*[IRF3.6set_all_with*/{T131* C2=C1;
T0* c1=__value;
r154set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,((/*RF2*/(C2)->_upper/*12*/))-((/*RF2*/(C2)->_lower/*16*/)));
}/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}


T0* r131twin(T131* C){
T0* R=NULL;
R=((void*)new131());
r131copy(((T131*)R),((T0*)C));
return R;
}


void r143copy(T143* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T143*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T143*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
(/*SFN*/C->_storage/*4*/)=new145((/*RF2*/(C)->_capacity/*8*/));
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r145copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T143*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}


T2 r143count(T143* C){
T2 R=0;
R=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
return R;
}


T2 r143item(T143* C,T2 a1){
T2 R=0;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}


void r143make(T143* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new145(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
/*[IRF3.6clear_all*/{T143* C1=C;
T2 __value=0;
/*[IRF3.6set_all_with*/{T143* C2=C1;
T2 c1=__value;
r145set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,((/*RF2*/(C2)->_upper/*12*/))-((/*RF2*/(C2)->_lower/*16*/)));
}/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}


T2 r143_px_64(T143* C,T2 a1){
T2 R=0;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}


T0* r143twin(T143* C){
T0* R=NULL;
R=((void*)new143());
r143copy(((T143*)R),((T0*)C));
return R;
}


void r143swap(T143* C,T2 a1,T2 a2){
T2 _tmp=0;
_tmp=r143item(C,a1);
/*[IRF3.6put*/{T143* C1=C;
T2 b1=r143item(C,a2);
T2 b2=a1;
((/*RF2*/(C1)->_storage/*4*/))[(b2)-((/*RF2*/(C1)->_lower/*16*/))]=(b1);
}/*]*/
/*[IRF3.6put*/{T143* C1=C;
T2 b1=_tmp;
T2 b2=a2;
((/*RF2*/(C1)->_storage/*4*/))[(b2)-((/*RF2*/(C1)->_lower/*16*/))]=(b1);
}/*]*/
}


void r137copy(T137* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T137*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T137*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
(/*SFN*/C->_storage/*4*/)=new139((/*RF2*/(C)->_capacity/*8*/));
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r139copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T137*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}


void r137make(T137* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new139(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
/*[IRF3.6clear_all*/{T137* C1=C;
T0* __value=NULL;
/*[IRF3.6set_all_with*/{T137* C2=C1;
T0* c1=__value;
r139set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,((/*RF2*/(C2)->_upper/*12*/))-((/*RF2*/(C2)->_lower/*16*/)));
}/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}


T0* r137_px_64(T137* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}


T0* r137twin(T137* C){
T0* R=NULL;
R=((void*)new137());
r137copy(((T137*)R),((T0*)C));
return R;
}


void r167copy(T167* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T167*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T167*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
(/*SFN*/C->_storage/*4*/)=new169((/*RF2*/(C)->_capacity/*8*/));
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r169copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T167*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}


T0* r167item(T167* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}


void r167make(T167* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new169(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
/*[IRF3.6clear_all*/{T167* C1=C;
T0* __value=NULL;
/*[IRF3.6set_all_with*/{T167* C2=C1;
T0* c1=__value;
r169set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,((/*RF2*/(C2)->_upper/*12*/))-((/*RF2*/(C2)->_lower/*16*/)));
}/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}


T0* r167_px_64(T167* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}


T0* r167twin(T167* C){
T0* R=NULL;
R=((void*)new167());
r167copy(((T167*)R),((T0*)C));
return R;
}


void r172copy(T172* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T172*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T172*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
(/*SFN*/C->_storage/*4*/)=new174((/*RF2*/(C)->_capacity/*8*/));
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r174copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T172*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}


void r172make(T172* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new174(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
/*[IRF3.6clear_all*/{T172* C1=C;
T0* __value=NULL;
/*[IRF3.6set_all_with*/{T172* C2=C1;
T0* c1=__value;
r174set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,((/*RF2*/(C2)->_upper/*12*/))-((/*RF2*/(C2)->_lower/*16*/)));
}/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}


T0* r172_px_64(T172* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}


T0* r172twin(T172* C){
T0* R=NULL;
R=((void*)new172());
r172copy(((T172*)R),((T0*)C));
return R;
}


void r150copy(T150* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T150*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T150*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
(/*SFN*/C->_storage/*4*/)=new152((/*RF2*/(C)->_capacity/*8*/));
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r152copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T150*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}


T0* r150item(T150* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}


void r150make(T150* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new152(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
/*[IRF3.6clear_all*/{T150* C1=C;
T0* __value=NULL;
/*[IRF3.6set_all_with*/{T150* C2=C1;
T0* c1=__value;
r152set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,((/*RF2*/(C2)->_upper/*12*/))-((/*RF2*/(C2)->_lower/*16*/)));
}/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}


T0* r150_px_64(T150* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}


T0* r150twin(T150* C){
T0* R=NULL;
R=((void*)new150());
r150copy(((T150*)R),((T0*)C));
return R;
}


void r184copy(T184* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T184*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T184*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
(/*SFN*/C->_storage/*4*/)=new9((/*RF2*/(C)->_capacity/*8*/));
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r9copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T184*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}


T3 r184item(T184* C,T2 a1){
T3 R=0;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}


void r184make(T184* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new9(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
/*[IRF3.6clear_all*/{T184* C1=C;
T3 __value=0;
/*[IRF3.6set_all_with*/{T184* C2=C1;
T3 c1=__value;
r9set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,((/*RF2*/(C2)->_upper/*12*/))-((/*RF2*/(C2)->_lower/*16*/)));
}/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}


T0* r184twin(T184* C){
T0* R=NULL;
R=((void*)new184());
r184copy(((T184*)R),((T0*)C));
return R;
}


void r155copy(T155* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T155*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T155*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
(/*SFN*/C->_storage/*4*/)=new157((/*RF2*/(C)->_capacity/*8*/));
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r157copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T155*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}


T0* r155item(T155* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}


void r155make(T155* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new157(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
/*[IRF3.6clear_all*/{T155* C1=C;
T0* __value=NULL;
/*[IRF3.6set_all_with*/{T155* C2=C1;
T0* c1=__value;
r157set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,((/*RF2*/(C2)->_upper/*12*/))-((/*RF2*/(C2)->_lower/*16*/)));
}/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}


T0* r155twin(T155* C){
T0* R=NULL;
R=((void*)new155());
r155copy(((T155*)R),((T0*)C));
return R;
}


void r140copy(T140* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T140*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T140*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
(/*SFN*/C->_storage/*4*/)=new142((/*RF2*/(C)->_capacity/*8*/));
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r142copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T140*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}


T0* r140item(T140* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}


void r140make(T140* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new142(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
/*[IRF3.6clear_all*/{T140* C1=C;
T0* __value=NULL;
/*[IRF3.6set_all_with*/{T140* C2=C1;
T0* c1=__value;
r142set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,((/*RF2*/(C2)->_upper/*12*/))-((/*RF2*/(C2)->_lower/*16*/)));
}/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}


T0* r140twin(T140* C){
T0* R=NULL;
R=((void*)new140());
r140copy(((T140*)R),((T0*)C));
return R;
}


void r147copy(T147* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T147*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T147*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
(/*SFN*/C->_storage/*4*/)=new149((/*RF2*/(C)->_capacity/*8*/));
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r149copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T147*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}


T0* r147item(T147* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}


void r147make(T147* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new149(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
/*[IRF3.6clear_all*/{T147* C1=C;
T0* __value=NULL;
/*[IRF3.6set_all_with*/{T147* C2=C1;
T0* c1=__value;
r149set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,((/*RF2*/(C2)->_upper/*12*/))-((/*RF2*/(C2)->_lower/*16*/)));
}/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}


T0* r147twin(T147* C){
T0* R=NULL;
R=((void*)new147());
r147copy(((T147*)R),((T0*)C));
return R;
}


void r182copy(T182* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=(/*RF2*/(((T182*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=(/*RF2*/(((T182*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
(/*SFN*/C->_storage/*4*/)=new181((/*RF2*/(C)->_capacity/*8*/));
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r181copy_from((/*RF2*/(C)->_storage/*4*/),(/*RF2*/(((T182*)a1))->_storage/*4*/),(_needed_capacity)-(1));
}
/*FI]*/
}


T2 r182count(T182* C){
T2 R=0;
R=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
return R;
}


T0* r182item(T182* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}


void r182make(T182* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new181(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
/*[IRF3.6clear_all*/{T182* C1=C;
T0* __value=NULL;
/*[IRF3.6set_all_with*/{T182* C2=C1;
T0* c1=__value;
r181set_all_with((/*RF2*/(C2)->_storage/*4*/),c1,((/*RF2*/(C2)->_upper/*12*/))-((/*RF2*/(C2)->_lower/*16*/)));
}/*]*/
}/*]*/
}
/*FI]*/
}
/*FI]*/
}


T0* r182_px_64(T182* C,T2 a1){
T0* R=NULL;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}


T0* r182twin(T182* C){
T0* R=NULL;
R=((void*)new182());
r182copy(((T182*)R),((T0*)C));
return R;
}


void r117copy(T117* C,T0* a1){
T2 _needed_capacity=0;
(/*SFN*/C->_lower/*16*/)=/*SSWARF2*//*X117lower*/(/*RF2*/(((T117*)a1))->_lower/*16*/);
(/*SFN*/C->_upper/*12*/)=/*SSWARF2*//*X117upper*/(/*RF2*/(((T117*)a1))->_upper/*12*/);
_needed_capacity=(((/*RF2*/(C)->_upper/*12*/))-((/*RF2*/(C)->_lower/*16*/)))+(1);
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed_capacity)){
(/*SFN*/C->_capacity/*8*/)=_needed_capacity;
(/*SFN*/C->_storage/*4*/)=new118((/*RF2*/(C)->_capacity/*8*/));
}
/*FI]*/
/*[IF*/
if((_needed_capacity)>(0)){
r118copy_from((/*RF2*/(C)->_storage/*4*/),/*SSWARF2*//*X117storage*/((T118)((/*RF2*/(((T117*)a1))->_storage/*4*/))),(_needed_capacity)-(1));
}
/*FI]*/
}


void r117clear_all(T117* C){
T5 _value=0;
/*[IRF3.6set_all_with*/{T117* C1=C;
T5 b1=_value;
r118set_all_with((/*RF2*/(C1)->_storage/*4*/),b1,((/*RF2*/(C1)->_upper/*12*/))-((/*RF2*/(C1)->_lower/*16*/)));
}/*]*/
}


T5 r117item(T117* C,T2 a1){
T5 R=0;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}


void r117make(T117* C,T2 a1,T2 a2){
T2 _needed=0;
(/*SFN*/C->_lower/*16*/)=a1;
(/*SFN*/C->_upper/*12*/)=a2;
_needed=((a2)-(a1))+(1);
/*[IF*/
if((_needed)>(0)){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))<(_needed)){
(/*SFN*/C->_storage/*4*/)=new118(_needed);
(/*SFN*/C->_capacity/*8*/)=_needed;
}
else{
r117clear_all(C);
}
/*FI]*/
}
/*FI]*/
}


T5 r117_px_64(T117* C,T2 a1){
T5 R=0;
R=((/*RF2*/(C)->_storage/*4*/))[(a1)-((/*RF2*/(C)->_lower/*16*/))];
return R;
}


T0* r117twin(T117* C){
T0* R=NULL;
R=((void*)new117());
r117copy(((T117*)R),((T0*)C));
return R;
}


void r196next(T196* C){
(/*SFN*/C->_item_index/*8*/)=((/*RF2*/(C)->_item_index/*8*/))+(1);
}


T0* r196item(T196* C){
T0* R=NULL;
R=X197item((/*RF2*/(C)->_dictionary/*4*/),(/*RF2*/(C)->_item_index/*8*/));
return R;
}


void r196make(T196* C,T0* a1){
(/*SFN*/C->_dictionary/*4*/)=a1;
(/*SFN*/C->_item_index/*8*/)=1;
}


T6 r196is_off(T196* C){
T6 R=0;
R=((/*RF2*/(C)->_item_index/*8*/))>(/*SSWARF2*//*X197count*/(/*RF2*/((T45*)((/*RF2*/(C)->_dictionary/*4*/)))->_count/*12*/));
return R;
}


T0* r196twin(T196* C){
T0* R=NULL;
R=((void*)new196());
*((T196*)R)=*C;
return R;
}


void r176make(T176* C,T0* a1,T2 a2,T0* a3){
(/*SFN*/C->_item/*4*/)=a1;
(/*SFN*/C->_key/*8*/)=a2;
(/*SFN*/C->_next/*12*/)=a3;
}


T0* r176twin(T176* C){
T0* R=NULL;
R=((void*)new176());
*((T176*)R)=*C;
return R;
}


void r113next(T113* C){
(/*SFN*/C->_current_link/*8*/)=(/*RF2*/((T81*)((/*RF2*/(C)->_current_link/*8*/)))->_next/*8*/);
}


void r113make(T113* C,T0* a1){
(/*SFN*/C->_linked_list/*4*/)=a1;
(/*SFN*/C->_current_link/*8*/)=(/*RF2*/((T80*)((/*RF2*/(C)->_linked_list/*4*/)))->_first_link/*8*/);
}


void r113start(T113* C){
(/*SFN*/C->_current_link/*8*/)=(/*RF2*/((T80*)((/*RF2*/(C)->_linked_list/*4*/)))->_first_link/*8*/);
}


T0* r113twin(T113* C){
T0* R=NULL;
R=((void*)new113());
*((T113*)R)=*C;
return R;
}


void r45copy(T45* C,T0* a1){
T2 _i=0;
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))==(0)){
r45with_capacity(C,((/*RF2*/(((T45*)a1))->_count/*12*/))+(1));
}
else{
r45clear(C);
}
/*FI]*/
_i=1;
while (!((_i)>((/*RF2*/(((T45*)a1))->_count/*12*/))))
{
r45put(C,r45item(((T45*)a1),_i),r45key(((T45*)a1),_i));
_i=(_i)+(1);
}
}


T0* r45key(T45* C,T2 a1){
T0* R=NULL;
r45set_cache_user(C,a1);
R=(/*RF2*/((T47*)((/*RF2*/(C)->_cache_node/*20*/)))->_key/*8*/);
return R;
}


T0* r45at(T45* C,T0* a1){
T0* R=NULL;
T0* _node=NULL;
T2 _idx=0;
_idx=(r7hash_code(((T7*)a1)))%((/*RF2*/(C)->_capacity/*8*/));
_node=((/*RF2*/(C)->_buckets/*4*/))[_idx];
while (!(r7is_equal((T7*)((/*RF2*/(((T47*)_node))->_key/*8*/)),a1)))
{
_node=(/*RF2*/(((T47*)_node))->_next/*12*/);
}
R=(/*RF2*/(((T47*)_node))->_item/*4*/);
return R;
}


void r45put(T45* C,T0* a1,T0* a2){
T0* _node=NULL;
T2 _idx=0;
T2 _h=0;
(/*SFN*/C->_cache_user/*16*/)=-(1);
_h=r7hash_code(((T7*)a2));
_idx=(_h)%((/*RF2*/(C)->_capacity/*8*/));
_node=((/*RF2*/(C)->_buckets/*4*/))[_idx];
while (!(((_node)==((void*)(NULL)))||(r7is_equal((T7*)((/*RF2*/(((T47*)_node))->_key/*8*/)),a2))))
{
_node=(/*RF2*/(((T47*)_node))->_next/*12*/);
}
/*[IF*/
if((_node)==((void*)(NULL))){
/*[IF*/
if(((/*RF2*/(C)->_capacity/*8*/))==((/*RF2*/(C)->_count/*12*/))){
r45increase_capacity(C);
_idx=(_h)%((/*RF2*/(C)->_capacity/*8*/));
}
/*FI]*/
{T47*n=new47();
r47make(n,a1,a2,((/*RF2*/(C)->_buckets/*4*/))[_idx]);
_node=((T0*)n);
}
((/*RF2*/(C)->_buckets/*4*/))[_idx]=(_node);
(/*SFN*/C->_count/*12*/)=((/*RF2*/(C)->_count/*12*/))+(1);
}
else{
/*[IRF3.3set_item*/((((T47*)(((T47*)_node))))->_item/*4*/)=(a1);
/*]*/
}
/*FI]*/
}


T0* r45item(T45* C,T2 a1){
T0* R=NULL;
r45set_cache_user(C,a1);
R=(/*RF2*/((T47*)((/*RF2*/(C)->_cache_node/*20*/)))->_item/*4*/);
return R;
}


void r45set_cache_user(T45* C,T2 a1){
/*[IF*/
if((a1)==(((/*RF2*/(C)->_cache_user/*16*/))+(1))){
(/*SFN*/C->_cache_user/*16*/)=a1;
(/*SFN*/C->_cache_node/*20*/)=(/*RF2*/((T47*)((/*RF2*/(C)->_cache_node/*20*/)))->_next/*12*/);
while (!(((/*RF2*/(C)->_cache_node/*20*/))!=((void*)(NULL))))
{
(/*SFN*/C->_cache_buckets/*24*/)=((/*RF2*/(C)->_cache_buckets/*24*/))+(1);
(/*SFN*/C->_cache_node/*20*/)=((/*RF2*/(C)->_buckets/*4*/))[(/*RF2*/(C)->_cache_buckets/*24*/)];
}
}
 else if((a1)==((/*RF2*/(C)->_cache_user/*16*/))){
}
 else if((a1)==(1)){
(/*SFN*/C->_cache_user/*16*/)=1;
(/*SFN*/C->_cache_buckets/*24*/)=0;
(/*SFN*/C->_cache_node/*20*/)=((/*RF2*/(C)->_buckets/*4*/))[(/*RF2*/(C)->_cache_buckets/*24*/)];
while (!(((/*RF2*/(C)->_cache_node/*20*/))!=((void*)(NULL))))
{
(/*SFN*/C->_cache_buckets/*24*/)=((/*RF2*/(C)->_cache_buckets/*24*/))+(1);
(/*SFN*/C->_cache_node/*20*/)=((/*RF2*/(C)->_buckets/*4*/))[(/*RF2*/(C)->_cache_buckets/*24*/)];
}
}
else{
r45set_cache_user(C,1);
while (!(((/*RF2*/(C)->_cache_user/*16*/))==(a1)))
{
r45set_cache_user(C,((/*RF2*/(C)->_cache_user/*16*/))+(1));
}
}
/*FI]*/
}


T0* r45get_new_iterator_on_items(T45* C){
T0* R=NULL;
{T218*n=new218();
r218make(n,(T0*)C);
R=((T0*)n);
}
return R;
}


void r45remove(T45* C,T0* a1){
T0* _previous_node=NULL;
T0* _node=NULL;
T2 _idx=0;
T2 _h=0;
(/*SFN*/C->_cache_user/*16*/)=-(1);
_h=r7hash_code(((T7*)a1));
_idx=(_h)%((/*RF2*/(C)->_capacity/*8*/));
_node=((/*RF2*/(C)->_buckets/*4*/))[_idx];
/*[IF*/
if((_node)!=((void*)(NULL))){
/*[IF*/
if(r7is_equal((T7*)((/*RF2*/(((T47*)_node))->_key/*8*/)),a1)){
(/*SFN*/C->_count/*12*/)=((/*RF2*/(C)->_count/*12*/))-(1);
_node=(/*RF2*/(((T47*)_node))->_next/*12*/);
((/*RF2*/(C)->_buckets/*4*/))[_idx]=(_node);
}
else{
_previous_node=_node;
_node=(/*RF2*/(((T47*)_node))->_next/*12*/);
while (!(((_node)==((void*)(NULL)))||(r7is_equal((T7*)((/*RF2*/(((T47*)_node))->_key/*8*/)),a1))))
{
_previous_node=_node;
_node=(/*RF2*/(((T47*)_node))->_next/*12*/);
}
/*[IF*/
if((_node)!=((void*)(NULL))){
(/*SFN*/C->_count/*12*/)=((/*RF2*/(C)->_count/*12*/))-(1);
/*[IRF3.3set_next*/((((T47*)(((T47*)_previous_node))))->_next/*12*/)=((/*RF2*/(((T47*)_node))->_next/*12*/));
/*]*/
}
/*FI]*/
}
/*FI]*/
}
/*FI]*/
}


void r45increase_capacity(T45* C){
int _hts=0;
T0* _node2=NULL;
T0* _node1=NULL;
T48 _old_buckets=NULL;
T2 _new_capacity=0;
T2 _idx=0;
T2 _i=0;
_new_capacity=r49prime_number_ceiling(((/*RF2*/(C)->_capacity/*8*/))+(1));
_old_buckets=(/*RF2*/(C)->_buckets/*4*/);
(/*SFN*/C->_buckets/*4*/)=new48(_new_capacity);
_i=((/*RF2*/(C)->_capacity/*8*/))-(1);
(/*SFN*/C->_capacity/*8*/)=_new_capacity;
while (!((_i)<(0)))
{
_node1=(_old_buckets)[_i];
while (!((_node1)==((void*)(NULL))))
{
_node2=(/*RF2*/(((T47*)_node1))->_next/*12*/);
_idx=(r7hash_code((T7*)((/*RF2*/(((T47*)_node1))->_key/*8*/))))%((/*RF2*/(C)->_capacity/*8*/));
/*[IRF3.3set_next*/((((T47*)(((T47*)_node1))))->_next/*12*/)=(((/*RF2*/(C)->_buckets/*4*/))[_idx]);
/*]*/
((/*RF2*/(C)->_buckets/*4*/))[_idx]=(_node1);
_node1=_node2;
}
_i=(_i)-(1);
}
(/*SFN*/C->_cache_user/*16*/)=-(1);
}


T6 r45has(T45* C,T0* a1){
T6 R=0;
T0* _node=NULL;
T2 _idx=0;
_idx=(r7hash_code(((T7*)a1)))%((/*RF2*/(C)->_capacity/*8*/));
_node=((/*RF2*/(C)->_buckets/*4*/))[_idx];
while (!(((_node)==((void*)(NULL)))||(r7is_equal((T7*)((/*RF2*/(((T47*)_node))->_key/*8*/)),a1))))
{
_node=(/*RF2*/(((T47*)_node))->_next/*12*/);
}
R=(_node)!=((void*)(NULL));
return R;
}


void r45clear(T45* C){
r48set_all_with((/*RF2*/(C)->_buckets/*4*/),NULL,((/*RF2*/(C)->_capacity/*8*/))-(1));
(/*SFN*/C->_cache_user/*16*/)=-(1);
(/*SFN*/C->_count/*12*/)=0;
}


T0* r45twin(T45* C){
T0* R=NULL;
R=((void*)new45());
r45copy(((T45*)R),((T0*)C));
return R;
}


void r45with_capacity(T45* C,T2 a1){
int _hts=0;
T2 _new_capacity=0;
_new_capacity=r49prime_number_ceiling(a1);
(/*SFN*/C->_buckets/*4*/)=new48(_new_capacity);
(/*SFN*/C->_capacity/*8*/)=_new_capacity;
(/*SFN*/C->_cache_user/*16*/)=-(1);
(/*SFN*/C->_count/*12*/)=0;
}


void r60copy(T60* C,T0* a1){
r60from_collection(C,a1);
}


T0* r60item(T60* C,T2 a1){
T0* R=NULL;
/*[IF*/
if((a1)!=((/*RF2*/(C)->_mem_idx/*16*/))){
r60go_item(C,a1);
}
/*FI]*/
R=(/*RF2*/((T61*)((/*RF2*/(C)->_mem_lnk/*20*/)))->_item/*4*/);
return R;
}


void r60make(T60* C){
(/*SFN*/C->_first_link/*8*/)=NULL;
(/*SFN*/C->_upper/*4*/)=0;
(/*SFN*/C->_last_link/*12*/)=NULL;
(/*SFN*/C->_mem_idx/*16*/)=0;
(/*SFN*/C->_mem_lnk/*20*/)=NULL;
}


T0* r60_px_64(T60* C,T2 a1){
T0* R=NULL;
/*[IF*/
if((a1)!=((/*RF2*/(C)->_mem_idx/*16*/))){
r60go_item(C,a1);
}
/*FI]*/
R=(/*RF2*/((T61*)((/*RF2*/(C)->_mem_lnk/*20*/)))->_item/*4*/);
return R;
}


void r60add_last(T60* C,T0* a1){
T0* _lnk=NULL;
/*[IF*/
if(((/*RF2*/(C)->_first_link/*8*/))==((void*)(NULL))){
{T61*n=new61();
r61make(n,a1,NULL);
(/*SFN*/C->_first_link/*8*/)=((T0*)n);
}
(/*SFN*/C->_upper/*4*/)=1;
(/*SFN*/C->_last_link/*12*/)=(/*RF2*/(C)->_first_link/*8*/);
(/*SFN*/C->_mem_idx/*16*/)=1;
(/*SFN*/C->_mem_lnk/*20*/)=(/*RF2*/(C)->_first_link/*8*/);
}
else{
{T61*n=new61();
r61make(n,a1,NULL);
_lnk=((T0*)n);
}
/*[IRF3.3set_next*/((((T61*)((T61*)((/*RF2*/(C)->_last_link/*12*/)))))->_next/*8*/)=(_lnk);
/*]*/
(/*SFN*/C->_upper/*4*/)=((/*RF2*/(C)->_upper/*4*/))+(1);
(/*SFN*/C->_last_link/*12*/)=_lnk;
}
/*FI]*/
}


void r60clear(T60* C){
/*[IF*/
if(((/*RF2*/(C)->_first_link/*8*/))!=((void*)(NULL))){
(/*SFN*/C->_first_link/*8*/)=NULL;
(/*SFN*/C->_mem_idx/*16*/)=0;
(/*SFN*/C->_mem_lnk/*20*/)=NULL;
(/*SFN*/C->_upper/*4*/)=0;
(/*SFN*/C->_last_link/*12*/)=NULL;
}
/*FI]*/
}


T2 r60fast_index_of(T60* C,T0* a1){
T2 R=0;
T2 _u=0;
R=1;
_u=(/*RF2*/(C)->_upper/*4*/);
while (!(((R)>(_u))||((a1)==((void*)(r60item(C,R))))))
{
R=(R)+(1);
}
return R;
}


T0* r60twin(T60* C){
T0* R=NULL;
R=((void*)new60());
r60copy(((T60*)R),((T0*)C));
return R;
}


void r60go_item(T60* C,T2 a1){
/*[IF*/
if(((/*RF2*/(C)->_mem_idx/*16*/))>(a1)){
(/*SFN*/C->_mem_idx/*16*/)=1;
(/*SFN*/C->_mem_lnk/*20*/)=(/*RF2*/(C)->_first_link/*8*/);
}
/*FI]*/
while (!((a1)==((/*RF2*/(C)->_mem_idx/*16*/))))
{
(/*SFN*/C->_mem_lnk/*20*/)=(/*RF2*/((T61*)((/*RF2*/(C)->_mem_lnk/*20*/)))->_next/*8*/);
(/*SFN*/C->_mem_idx/*16*/)=((/*RF2*/(C)->_mem_idx/*16*/))+(1);
}
}


void r60from_collection(T60* C,T0* a1){
T0* _lnk=NULL;
T2 _up=0;
T2 _i=0;
/*[IF*/
if(((/*RF2*/(C)->_first_link/*8*/))==((void*)(NULL))){
_i=1;
_up=(/*RF2*/(((T60*)a1))->_upper/*4*/);
while (!((_i)>(_up)))
{
r60add_last(C,r60item(((T60*)a1),_i));
_i=(_i)+(1);
}
}
else{
_lnk=(/*RF2*/(C)->_first_link/*8*/);
_i=1;
_up=(/*RF2*/(((T60*)a1))->_upper/*4*/);
while (!((_i)>(_up)))
{
/*[IF*/
if((_lnk)==((void*)(NULL))){
r60add_last(C,r60item(((T60*)a1),_i));
}
else{
/*[IRF3.3set_item*/((((T61*)(((T61*)_lnk))))->_item/*4*/)=(r60item(((T60*)a1),_i));
/*]*/
_lnk=(/*RF2*/(((T61*)_lnk))->_next/*8*/);
}
/*FI]*/
_i=(_i)+(1);
}
/*[IF*/
if((_lnk)==((void*)((/*RF2*/(C)->_first_link/*8*/)))){
r60clear(C);
}
 else if((_lnk)!=((void*)(NULL))){
_i=/*(IRF4.3count*/(/*RF2*/(((T60*)a1))->_upper/*4*/)/*)*/;
/*[IF*/
if(((/*RF2*/(C)->_mem_idx/*16*/))!=(_i)){
r60go_item(C,_i);
}
/*FI]*/
/*[IRF3.3set_next*/((((T61*)((T61*)((/*RF2*/(C)->_mem_lnk/*20*/)))))->_next/*8*/)=(NULL);
/*]*/
(/*SFN*/C->_upper/*4*/)=_i;
(/*SFN*/C->_last_link/*12*/)=(/*RF2*/(C)->_mem_lnk/*20*/);
}
/*FI]*/
}
/*FI]*/
}

